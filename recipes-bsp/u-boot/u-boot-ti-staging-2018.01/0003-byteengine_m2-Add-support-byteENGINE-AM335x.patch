From e5155dffb7ac39217c1b1403441d2a184870710e Mon Sep 17 00:00:00 2001
From: Daniel Ammann <daniel.ammann@bytesatwork.ch>
Date: Tue, 10 Jul 2018 11:00:42 +0200
Subject: [PATCH 3/4] byteengine_m2: Add support byteENGINE AM335x

---
 arch/arm/dts/byteengine-m2-rev4.dts                | 276 ++++++++++++++++
 arch/arm/dts/byteengine-m2.dts                     | 304 ++++++++++++++++++
 arch/arm/mach-omap2/Kconfig                        |   1 +
 arch/arm/mach-omap2/am33xx/Kconfig                 |  18 ++
 board/bytesatwork/byteengine_m2/Kconfig            |  74 +++++
 board/bytesatwork/byteengine_m2/MAINTAINERS        |   6 +
 board/bytesatwork/byteengine_m2/Makefile           |  23 ++
 board/bytesatwork/byteengine_m2/board.c            | 276 ++++++++++++++++
 board/bytesatwork/byteengine_m2/board.h            |  38 +++
 board/bytesatwork/byteengine_m2/ddr_defs_baw.h     |  60 ++++
 board/bytesatwork/byteengine_m2/m2config/README    |  68 ++++
 .../byteengine_m2/m2config/cmd_m2config.c          | 220 +++++++++++++
 .../bytesatwork/byteengine_m2/m2config/m2config.c  |  47 +++
 .../bytesatwork/byteengine_m2/m2config/m2config.h  |  81 +++++
 .../byteengine_m2/m2config/m2config_builtin.c      |  17 +
 .../byteengine_m2/m2config/m2config_builtin.h      |  23 ++
 .../byteengine_m2/m2config/m2config_eeprom.c       | 238 ++++++++++++++
 .../byteengine_m2/m2config/m2config_eeprom.h       |  38 +++
 .../byteengine_m2/m2config/m2config_get.c          |  38 +++
 .../byteengine_m2/m2config/m2config_get.h          |  15 +
 board/bytesatwork/byteengine_m2/mux.c              | 140 ++++++++
 board/bytesatwork/byteengine_m2/ram.c              | 354 +++++++++++++++++++++
 board/bytesatwork/byteengine_m2/u-boot.lds         | 158 +++++++++
 configs/byteengine_m2_defconfig                    |  62 ++++
 configs/byteengine_m2_rev4_defconfig               |  63 ++++
 include/configs/byteengine_m2.h                    | 214 +++++++++++++
 include/configs/byteengine_m2_rev4.h               | 173 ++++++++++
 27 files changed, 3025 insertions(+)
 create mode 100644 arch/arm/dts/byteengine-m2-rev4.dts
 create mode 100644 arch/arm/dts/byteengine-m2.dts
 create mode 100644 board/bytesatwork/byteengine_m2/Kconfig
 create mode 100644 board/bytesatwork/byteengine_m2/MAINTAINERS
 create mode 100644 board/bytesatwork/byteengine_m2/Makefile
 create mode 100644 board/bytesatwork/byteengine_m2/board.c
 create mode 100644 board/bytesatwork/byteengine_m2/board.h
 create mode 100644 board/bytesatwork/byteengine_m2/ddr_defs_baw.h
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/README
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/cmd_m2config.c
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/m2config.c
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/m2config.h
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/m2config_builtin.c
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/m2config_builtin.h
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/m2config_eeprom.c
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/m2config_eeprom.h
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/m2config_get.c
 create mode 100644 board/bytesatwork/byteengine_m2/m2config/m2config_get.h
 create mode 100644 board/bytesatwork/byteengine_m2/mux.c
 create mode 100644 board/bytesatwork/byteengine_m2/ram.c
 create mode 100644 board/bytesatwork/byteengine_m2/u-boot.lds
 create mode 100644 configs/byteengine_m2_defconfig
 create mode 100644 configs/byteengine_m2_rev4_defconfig
 create mode 100644 include/configs/byteengine_m2.h
 create mode 100644 include/configs/byteengine_m2_rev4.h

diff --git a/arch/arm/dts/byteengine-m2-rev4.dts b/arch/arm/dts/byteengine-m2-rev4.dts
new file mode 100644
index 0000000000..839ee9f8d7
--- /dev/null
+++ b/arch/arm/dts/byteengine-m2-rev4.dts
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on am335x-evm.dts
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "am33xx.dtsi"
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "bytesatwork byteENGINE AM335x";
+	compatible = "bytesatwork,byteengine-m2", "ti,am33xx";
+
+	chosen {
+		stdout-path = &uart0;
+		tick-timer = &timer2;
+	};
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&vdd1_reg>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+	vbat: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbat";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-boot-on;
+	};
+};
+
+&am33xx_pinmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&clkout2_pin>;
+
+	i2c0_pins: pinmux_i2c0_pins {
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_sda.i2c0_sda */
+			0x18c (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_scl.i2c0_scl */
+		>;
+	};
+
+	uart0_pins: pinmux_uart0_pins {
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart0_rxd.uart0_rxd */
+			0x174 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart0_txd.uart0_txd */
+		>;
+	};
+
+	uart1_pins: pinmux_uart1_pins {
+		pinctrl-single,pins = <
+			0x178 (PIN_INPUT | MUX_MODE0)		/* uart1_ctsn.uart1_ctsn */
+			0x17C (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart1_rtsn.uart1_rtsn */
+			0x180 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart1_rxd.uart1_rxd */
+			0x184 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart1_txd.uart1_txd */
+		>;
+	};
+
+	clkout2_pin: pinmux_clkout2_pin {
+		pinctrl-single,pins = <
+			0x1b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr1.clkout2 */
+		>;
+	};
+
+	cpsw_default: cpsw_default {
+		pinctrl-single,pins = <
+			/* Slave 1 */
+			0x114 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txen.rgmii1_tctl */
+			0x118 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxdv.rgmii1_rctl */
+			0x11c (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd3.rgmii1_td3 */
+			0x120 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd2.rgmii1_td2 */
+			0x124 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd1.rgmii1_td1 */
+			0x128 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd0.rgmii1_td0 */
+			0x12c (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txclk.rgmii1_tclk */
+			0x130 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxclk.rgmii1_rclk */
+			0x134 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd3.rgmii1_rd3 */
+			0x138 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd2.rgmii1_rd2 */
+			0x13c (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd1.rgmii1_rd1 */
+			0x140 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd0.rgmii1_rd0 */
+		>;
+	};
+
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0)	/* mdio_data.mdio_data */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE0)			/* mdio_clk.mdio_clk */
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x160 (PIN_INPUT | MUX_MODE7) /* spi0_cs1.gpio0_6 */
+		>;
+	};
+
+	mmc2_pins: pinmux_mmc2_pins {
+		pinctrl-single,pins = <
+			0x80 (PIN_INPUT_PULLUP | MUX_MODE2) /* gpmc_csn1.mmc1_clk */
+			0x84 (PIN_INPUT_PULLUP | MUX_MODE2) /* gpmc_csn2.mmc1_cmd */
+			0x00 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad0.mmc1_dat0 */
+			0x04 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad1.mmc1_dat1 */
+			0x08 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad2.mmc1_dat2 */
+			0x0c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad3.mmc1_dat3 */
+			0x10 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad4.mmc1_dat4 */
+			0x14 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad5.mmc1_dat5 */
+			0x18 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad6.mmc1_dat6 */
+			0x1c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad7.mmc1_dat7 */
+		>;
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+
+	status = "okay";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+
+	status = "okay";
+	clock-frequency = <400000>;
+
+	tps: tps@2d {
+		reg = <0x2d>;
+	};
+};
+
+&cppi41dma  {
+	status = "okay";
+};
+
+&elm {
+	status = "okay";
+};
+
+&gpmc {
+	status = "disabled";
+};
+
+#include "tps65910.dtsi"
+
+&tps {
+	vcc1-supply = <&vbat>;
+	vcc2-supply = <&vbat>;
+	vcc3-supply = <&vbat>;
+	vcc4-supply = <&vbat>;
+	vcc5-supply = <&vbat>;
+	vcc6-supply = <&vbat>;
+	vcc7-supply = <&vbat>;
+	vccio-supply = <&vbat>;
+
+	regulators {
+		vrtc_reg: regulator@0 {
+			regulator-always-on;
+		};
+
+		vio_reg: regulator@1 {
+			regulator-always-on;
+		};
+
+		vdd1_reg: regulator@2 {
+			/* VDD_MPU voltage limits 0.95V - 1.26V with +/-4% tolerance */
+			regulator-name = "vdd_mpu";
+			regulator-min-microvolt = <912500>;
+			regulator-max-microvolt = <1312500>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vdd2_reg: regulator@3 {
+			/* VDD_CORE voltage limits 0.95V - 1.1V with +/-4% tolerance */
+			regulator-name = "vdd_core";
+			regulator-min-microvolt = <912500>;
+			regulator-max-microvolt = <1150000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vdd3_reg: regulator@4 {
+			regulator-always-on;
+		};
+
+		vdig1_reg: regulator@5 {
+			regulator-always-on;
+		};
+
+		vdig2_reg: regulator@6 {
+			regulator-always-on;
+		};
+
+		vpll_reg: regulator@7 {
+			regulator-always-on;
+		};
+
+		vdac_reg: regulator@8 {
+			regulator-always-on;
+		};
+
+		vaux1_reg: regulator@9 {
+			regulator-always-on;
+		};
+
+		vaux2_reg: regulator@10 {
+			regulator-always-on;
+		};
+
+		vaux33_reg: regulator@11 {
+			regulator-always-on;
+		};
+
+		vmmc_reg: regulator@12 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+	};
+};
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default>;
+	status = "okay";
+};
+
+&davinci_mdio {
+	pinctrl-names = "default";
+	pinctrl-0 = <&davinci_mdio_default>;
+	status = "okay";
+};
+
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <0>;
+	phy-mode = "rgmii-txid";
+};
+
+&mmc1 {
+	status = "okay";
+	vmmc-supply = <&vmmc_reg>;
+	bus-width = <4>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	cd-gpios = <&gpio0 6 GPIO_ACTIVE_LOW>;
+};
+
+&mmc2 {
+	status = "okay";
+	vmmc-supply = <&vmmc_reg>;
+	bus-width = <8>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc2_pins>;
+	non-removable;
+};
+
+&edma {
+	ti,edma-xbar-event-map = /bits/ 16 <1 12
+					    2 13>;
+};
diff --git a/arch/arm/dts/byteengine-m2.dts b/arch/arm/dts/byteengine-m2.dts
new file mode 100644
index 0000000000..c9599c7082
--- /dev/null
+++ b/arch/arm/dts/byteengine-m2.dts
@@ -0,0 +1,304 @@
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on am335x-evm.dts
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "am33xx.dtsi"
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "bytesatwork byteENGINE AM335x";
+	compatible = "bytesatwork,byteengine-m2", "ti,am33xx";
+
+	chosen {
+		stdout-path = &uart0;
+		tick-timer = &timer2;
+	};
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&vdd1_reg>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+	vbat: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbat";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-boot-on;
+	};
+};
+
+&am33xx_pinmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&clkout2_pin>;
+
+	i2c0_pins: pinmux_i2c0_pins {
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_sda.i2c0_sda */
+			0x18c (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_scl.i2c0_scl */
+		>;
+	};
+
+	uart0_pins: pinmux_uart0_pins {
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart0_rxd.uart0_rxd */
+			0x174 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart0_txd.uart0_txd */
+		>;
+	};
+
+	uart1_pins: pinmux_uart1_pins {
+		pinctrl-single,pins = <
+			0x178 (PIN_INPUT | MUX_MODE0)		/* uart1_ctsn.uart1_ctsn */
+			0x17C (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart1_rtsn.uart1_rtsn */
+			0x180 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart1_rxd.uart1_rxd */
+			0x184 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart1_txd.uart1_txd */
+		>;
+	};
+
+	clkout2_pin: pinmux_clkout2_pin {
+		pinctrl-single,pins = <
+			0x1b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr1.clkout2 */
+		>;
+	};
+
+	nandflash_pins_s0: nandflash_pins_s0 {
+		pinctrl-single,pins = <
+			0x0 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad0.gpmc_ad0 */
+			0x4 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad1.gpmc_ad1 */
+			0x8 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad2.gpmc_ad2 */
+			0xc (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad3.gpmc_ad3 */
+			0x10 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad4.gpmc_ad4 */
+			0x14 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad5.gpmc_ad5 */
+			0x18 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad6.gpmc_ad6 */
+			0x1c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad7.gpmc_ad7 */
+			0x70 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */
+			0x74 (PIN_INPUT_PULLUP | MUX_MODE7)	/* gpmc_wpn.gpio0_30 */
+			0x7c (PIN_OUTPUT | MUX_MODE0)		/* gpmc_csn0.gpmc_csn0  */
+			0x90 (PIN_OUTPUT | MUX_MODE0)		/* gpmc_advn_ale.gpmc_advn_ale */
+			0x94 (PIN_OUTPUT | MUX_MODE0)		/* gpmc_oen_ren.gpmc_oen_ren */
+			0x98 (PIN_OUTPUT | MUX_MODE0)		/* gpmc_wen.gpmc_wen */
+			0x9c (PIN_OUTPUT | MUX_MODE0)		/* gpmc_be0n_cle.gpmc_be0n_cle */
+		>;
+	};
+
+	cpsw_default: cpsw_default {
+		pinctrl-single,pins = <
+			/* Slave 1 */
+			0x114 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txen.rgmii1_tctl */
+			0x118 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxdv.rgmii1_rctl */
+			0x11c (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd3.rgmii1_td3 */
+			0x120 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd2.rgmii1_td2 */
+			0x124 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd1.rgmii1_td1 */
+			0x128 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd0.rgmii1_td0 */
+			0x12c (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txclk.rgmii1_tclk */
+			0x130 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxclk.rgmii1_rclk */
+			0x134 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd3.rgmii1_rd3 */
+			0x138 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd2.rgmii1_rd2 */
+			0x13c (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd1.rgmii1_rd1 */
+			0x140 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd0.rgmii1_rd0 */
+		>;
+	};
+
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0)	/* mdio_data.mdio_data */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE0)			/* mdio_clk.mdio_clk */
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x160 (PIN_INPUT | MUX_MODE7) /* spi0_cs1.gpio0_6 */
+		>;
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+
+	status = "okay";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+
+	status = "okay";
+	clock-frequency = <400000>;
+
+	tps: tps@2d {
+		reg = <0x2d>;
+	};
+};
+
+&cppi41dma  {
+	status = "okay";
+};
+
+&elm {
+	status = "okay";
+};
+
+&gpmc {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&nandflash_pins_s0>;
+	ranges = <0 0 0x08000000 0x10000000>;	/* CS0: 16MB for NAND */
+	nand@0,0 {
+		reg = <0 0 4>; /* CS0, offset 0, IO size 4 */
+		ti,nand-ecc-opt = "ham1";
+		ti,elm-id = <&elm>;
+		nand-bus-width = <8>;
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+	};
+};
+
+#include "tps65910.dtsi"
+
+&tps {
+	vcc1-supply = <&vbat>;
+	vcc2-supply = <&vbat>;
+	vcc3-supply = <&vbat>;
+	vcc4-supply = <&vbat>;
+	vcc5-supply = <&vbat>;
+	vcc6-supply = <&vbat>;
+	vcc7-supply = <&vbat>;
+	vccio-supply = <&vbat>;
+
+	regulators {
+		vrtc_reg: regulator@0 {
+			regulator-always-on;
+		};
+
+		vio_reg: regulator@1 {
+			regulator-always-on;
+		};
+
+		vdd1_reg: regulator@2 {
+			/* VDD_MPU voltage limits 0.95V - 1.26V with +/-4% tolerance */
+			regulator-name = "vdd_mpu";
+			regulator-min-microvolt = <912500>;
+			regulator-max-microvolt = <1312500>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vdd2_reg: regulator@3 {
+			/* VDD_CORE voltage limits 0.95V - 1.1V with +/-4% tolerance */
+			regulator-name = "vdd_core";
+			regulator-min-microvolt = <912500>;
+			regulator-max-microvolt = <1150000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vdd3_reg: regulator@4 {
+			regulator-always-on;
+		};
+
+		vdig1_reg: regulator@5 {
+			regulator-always-on;
+		};
+
+		vdig2_reg: regulator@6 {
+			regulator-always-on;
+		};
+
+		vpll_reg: regulator@7 {
+			regulator-always-on;
+		};
+
+		vdac_reg: regulator@8 {
+			regulator-always-on;
+		};
+
+		vaux1_reg: regulator@9 {
+			regulator-always-on;
+		};
+
+		vaux2_reg: regulator@10 {
+			regulator-always-on;
+		};
+
+		vaux33_reg: regulator@11 {
+			regulator-always-on;
+		};
+
+		vmmc_reg: regulator@12 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+	};
+};
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default>;
+	status = "okay";
+};
+
+&davinci_mdio {
+	pinctrl-names = "default";
+	pinctrl-0 = <&davinci_mdio_default>;
+	status = "okay";
+};
+
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <0>;
+	phy-mode = "rgmii-txid";
+};
+
+&mmc1 {
+	status = "okay";
+	vmmc-supply = <&vmmc_reg>;
+	bus-width = <4>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	cd-gpios = <&gpio0 6 GPIO_ACTIVE_LOW>;
+};
+
+&edma {
+	ti,edma-xbar-event-map = /bits/ 16 <1 12
+					    2 13>;
+};
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index 62c25c4044..b99136cf04 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -176,6 +176,7 @@ source "board/ti/ti814x/Kconfig"
 source "board/ti/ti816x/Kconfig"
 source "board/ti/am43xx/Kconfig"
 source "board/ti/am335x/Kconfig"
+source "board/bytesatwork/byteengine_m2/Kconfig"
 source "board/compulab/cm_t335/Kconfig"
 source "board/compulab/cm_t43/Kconfig"
 
diff --git a/arch/arm/mach-omap2/am33xx/Kconfig b/arch/arm/mach-omap2/am33xx/Kconfig
index fd473f118b..196497bbda 100644
--- a/arch/arm/mach-omap2/am33xx/Kconfig
+++ b/arch/arm/mach-omap2/am33xx/Kconfig
@@ -112,6 +112,24 @@ config TARGET_BRPPT1
 	bool "Support BRPPT1"
 	select BOARD_LATE_INIT
 
+config TARGET_BYTEENGINE_M2
+	bool "Support byteengine_m2"
+	select BOARD_LATE_INIT
+	select DM
+	select DM_SERIAL
+	select DM_GPIO
+	help
+	  Support for the bytesatwork m2 module (with nand flash).
+
+config TARGET_BYTEENGINE_M2_REV4
+	bool "Support byteengine m2 rev 4"
+	select BOARD_LATE_INIT
+	select DM
+	select DM_SERIAL
+	select DM_GPIO
+	help
+	  Support for the bytesatwork m2 module (with eMMC).
+
 config TARGET_CHILIBOARD
 	bool "Grinn chiliBoard"
 	select AM33XX_CHILISOM
diff --git a/board/bytesatwork/byteengine_m2/Kconfig b/board/bytesatwork/byteengine_m2/Kconfig
new file mode 100644
index 0000000000..bbac642fdf
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/Kconfig
@@ -0,0 +1,74 @@
+if TARGET_BYTEENGINE_M2
+
+config SYS_BOARD
+	default "byteengine_m2"
+
+config SYS_VENDOR
+	default "bytesatwork"
+
+config SYS_SOC
+	default "am33xx"
+
+config SYS_CONFIG_NAME
+	default "byteengine_m2"
+
+config CONS_INDEX
+	int "UART used for console"
+	range 1 6
+	default 1
+	help
+	  The AM335x SoC has a total of 6 UARTs (UART0 to UART5 as referenced
+	  in documentation, etc) available to it.  Depending on your specific
+	  board you may want something other than UART0 as for example the IDK
+	  uses UART3 so enter 4 here.
+
+endif
+
+if TARGET_BYTEENGINE_M2 || TARGET_BYTEENGINE_M2_REV4
+
+config CMD_M2CONFIG
+	bool "m2config command"
+	depends on M2CONFIG_EEPROM || M2CONFIG_BUILTIN
+	default y
+	help
+	  Enable m2config command functionality.
+
+config M2CONFIG_EEPROM
+	bool "m2config eeprom support"
+	default y
+	help
+	  Enable m2config EEPROM read/write functionality.
+
+config M2CONFIG_BUILTIN
+	bool "m2config builtin support"
+	default y
+	help
+	  Enable m2config builtin configuration functionality.
+
+endif
+
+if TARGET_BYTEENGINE_M2_REV4
+
+config SYS_BOARD
+	default "byteengine_m2"
+
+config SYS_VENDOR
+	default "bytesatwork"
+
+config SYS_SOC
+	default "am33xx"
+
+config SYS_CONFIG_NAME
+	default "byteengine_m2_rev4"
+
+config CONS_INDEX
+	int "UART used for console"
+	range 1 6
+	default 1
+	help
+	  The AM335x SoC has a total of 6 UARTs (UART0 to UART5 as referenced
+	  in documentation, etc) available to it.  Depending on your specific
+	  board you may want something other than UART0 as for example the IDK
+	  uses UART3 so enter 4 here.
+
+endif
diff --git a/board/bytesatwork/byteengine_m2/MAINTAINERS b/board/bytesatwork/byteengine_m2/MAINTAINERS
new file mode 100644
index 0000000000..fc2c414fa7
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/MAINTAINERS
@@ -0,0 +1,6 @@
+BYTEENGINE_M2
+M:	Markus Kappeler <markus.kappeler@bytesatwork.ch>
+S:	Maintained
+F:	board/bytesatwork/byteengine_m2/
+F:	include/configs/byteengine_m2.h
+F:	configs/byteengine_m2_defconfig
diff --git a/board/bytesatwork/byteengine_m2/Makefile b/board/bytesatwork/byteengine_m2/Makefile
new file mode 100644
index 0000000000..22549a2c88
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/Makefile
@@ -0,0 +1,23 @@
+#
+# Makefile
+#
+# Copyright (C) 2018 bytes at work AG
+#
+# Based on board/ti/am335x/Makefile
+#
+# Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifeq ($(CONFIG_SKIP_LOWLEVEL_INIT),)
+obj-y	:= mux.o
+obj-y	+= ram.o
+endif
+
+obj-y	+= board.o
+obj-y	+= m2config/m2config.o
+obj-y	+= m2config/m2config_get.o
+obj-$(CONFIG_M2CONFIG_EEPROM)	+= m2config/m2config_eeprom.o
+obj-$(CONFIG_M2CONFIG_BUILTIN)	+= m2config/m2config_builtin.o
+obj-$(CONFIG_CMD_M2CONFIG)	+= m2config/cmd_m2config.o
diff --git a/board/bytesatwork/byteengine_m2/board.c b/board/bytesatwork/byteengine_m2/board.c
new file mode 100644
index 0000000000..ca26fb5ce6
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/board.c
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on board/ti/am335x/board.c
+ *
+ * Board functions for TI AM335X based boards
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <spl.h>
+#include <serial.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/clk_synthesizer.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <asm/omap_common.h>
+#include <asm/omap_sec_common.h>
+#include <asm/omap_mmc.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include <power/tps65217.h>
+#include <power/tps65910.h>
+#include <environment.h>
+#include <watchdog.h>
+#include <environment.h>
+#include "board.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+#ifndef CONFIG_DM_SERIAL
+struct serial_device *default_serial_console(void)
+{
+	return &eserial1_device;
+}
+#endif
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+
+void am33xx_spl_board_init(void)
+{
+	int mpu_vdd;
+	int sil_rev;
+
+	/* Get the frequency */
+	dpll_mpu_opp100.m = am335x_get_efuse_mpu_max_freq(cdev);
+
+	/*
+	 * Depending on MPU clock and PG we will need a different
+	 * VDD to drive at that speed.
+	 */
+	sil_rev = readl(&cdev->deviceid) >> 28;
+	mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev,
+					      dpll_mpu_opp100.m);
+
+	/* Tell the TPS65910 to use i2c */
+	tps65910_set_i2c_control();
+
+	/* First update MPU voltage. */
+	if (tps65910_voltage_update(MPU, mpu_vdd))
+		return;
+
+	/* Second, update the CORE voltage. */
+	if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_3))
+		return;
+
+	/* Set CORE Frequencies to OPP100 */
+	do_setup_dpll(&dpll_core_regs, &dpll_core_opp100);
+
+	/* Set MPU Frequency to what we detected now that voltages are set */
+	do_setup_dpll(&dpll_mpu_regs, &dpll_mpu_opp100);
+}
+
+void set_uart_mux_conf(void)
+{
+	enable_uart0_pin_mux();
+}
+
+void set_mux_conf_regs(void)
+{
+	enable_board_pin_mux();
+}
+
+#endif
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+#if defined(CONFIG_HW_WATCHDOG)
+	hw_watchdog_init();
+#endif
+
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+#if defined(CONFIG_NOR) || defined(CONFIG_NAND)
+	gpmc_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+#if defined(CONFIG_NAND)
+	omap_nand_switch_ecc(1, 1);
+#endif
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_DM_ETH
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+static void cpsw_control(int enabled)
+{
+	/* VTP can be added here */
+
+	return;
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+	{
+		.slave_reg_ofs	= 0x208,
+		.sliver_reg_ofs	= 0xd80,
+		.phy_addr	= 0,
+	},
+	{
+		.slave_reg_ofs	= 0x308,
+		.sliver_reg_ofs	= 0xdc0,
+		.phy_addr	= 1,
+	},
+};
+
+static struct cpsw_platform_data cpsw_data = {
+	.mdio_base		= CPSW_MDIO_BASE,
+	.cpsw_base		= CPSW_BASE,
+	.mdio_div		= 0xff,
+	.channels		= 8,
+	.cpdma_reg_ofs		= 0x800,
+	.slaves			= 1,
+	.slave_data		= cpsw_slaves,
+	.ale_reg_ofs		= 0xd00,
+	.ale_entries		= 1024,
+	.host_port_reg_ofs	= 0x108,
+	.hw_stats_reg_ofs	= 0x900,
+	.bd_ram_ofs		= 0x2000,
+	.mac_control		= (1 << 5),
+	.control		= cpsw_control,
+	.host_port_num		= 0,
+	.version		= CPSW_CTRL_VERSION_2,
+};
+#endif
+
+#endif /* CONFIG_DM_ETH */
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	return -1;
+}
+#endif
+
+/*
+ * This function will:
+ * Read the eFuse for MAC addresses, and set ethaddr/eth1addr/usbnet_devaddr
+ * in the environment
+ * Perform fixups to the PHY present on certain boards.  We only need this
+ * function in:
+ * - SPL with either CPSW or USB ethernet support
+ * - Full U-Boot, with either CPSW or USB ethernet
+ * Build in only these cases to avoid warnings about unused variables
+ * when we build an SPL that has neither option but full U-Boot will.
+ */
+#if ((defined(CONFIG_SPL_ETH_SUPPORT) || defined(CONFIG_SPL_USBETH_SUPPORT)) \
+	&& defined(CONFIG_SPL_BUILD)) || \
+	((defined(CONFIG_DRIVER_TI_CPSW) || \
+	  defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET)) && \
+	 !defined(CONFIG_SPL_BUILD))
+int board_eth_init(bd_t *bis)
+{
+	int rv, n = 0;
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+
+	/* try reading mac address from efuse */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+	if (!env_get("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("ethaddr", mac_addr);
+	}
+
+#ifdef CONFIG_DRIVER_TI_CPSW
+
+	mac_lo = readl(&cdev->macid1l);
+	mac_hi = readl(&cdev->macid1h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!env_get("eth1addr")) {
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("eth1addr", mac_addr);
+	}
+
+	writel(MII_MODE_ENABLE, &cdev->miisel);
+	cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
+				PHY_INTERFACE_MODE_MII;
+
+	rv = cpsw_register(&cpsw_data);
+	if (rv < 0)
+		printf("Error %d registering CPSW switch\n", rv);
+	else
+		n += rv;
+#endif
+
+	/*
+	 *
+	 * CPSW RGMII Internal Delay Mode is not supported in all PVT
+	 * operating points.  So we must set the TX clock delay feature
+	 * in the AR8051 PHY.  Since we only support a single ethernet
+	 * device in U-Boot, we only do this for the first instance.
+	 */
+#define AR8051_PHY_DEBUG_ADDR_REG	0x1d
+#define AR8051_PHY_DEBUG_DATA_REG	0x1e
+#define AR8051_DEBUG_RGMII_CLK_DLY_REG	0x5
+#define AR8051_RGMII_TX_CLK_DLY		0x100
+
+#endif
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USBETH_SUPPORT))
+	if (is_valid_ethaddr(mac_addr))
+		eth_setenv_enetaddr("usbnet_devaddr", mac_addr);
+
+	rv = usb_eth_initialize(bis);
+	if (rv < 0)
+		printf("Error %d registering USB_ETHER\n", rv);
+	else
+		n += rv;
+#endif
+	return n;
+}
+#endif
diff --git a/board/bytesatwork/byteengine_m2/board.h b/board/bytesatwork/byteengine_m2/board.h
new file mode 100644
index 0000000000..732586497d
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/board.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on board/ti/am335x/board.h
+ *
+ * TI AM335x boards information header
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef BOARD_H
+#define BOARD_H
+
+/**
+ * AM335X (EMIF_4D) EMIF REG_COS_COUNT_1, REG_COS_COUNT_2, and
+ * REG_PR_OLD_COUNT values to avoid LCDC DMA FIFO underflows and Frame
+ * Synchronization Lost errors. The values are the biggest that work
+ * reliably with offered video modes and the memory subsystem on the
+ * boards. These register have are briefly documented in "7.3.3.5.2
+ * Command Starvation" section of AM335x TRM. The REG_COS_COUNT_1 and
+ * REG_COS_COUNT_2 do not have any effect on current versions of
+ * AM335x.
+ */
+#define EMIF_OCP_CONFIG				EMIF1_BASE + 0x54
+#define EMIF_OCP_CONFIG_BYTEENGINE_M2		0x00383838
+
+/*
+ * We have three pin mux functions that must exist.  We must be able to enable
+ * uart0, for initial output and i2c0 to read the main EEPROM.  We then have a
+ * main pinmux function that can be overridden to enable all other pinmux that
+ * is required on the board.
+ */
+void enable_uart0_pin_mux(void);
+void enable_i2c0_pin_mux(void);
+void enable_board_pin_mux(void);
+#endif
diff --git a/board/bytesatwork/byteengine_m2/ddr_defs_baw.h b/board/bytesatwork/byteengine_m2/ddr_defs_baw.h
new file mode 100644
index 0000000000..a212adebc4
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/ddr_defs_baw.h
@@ -0,0 +1,60 @@
+/*
+ * ddr definitions for chips used by bytes at work
+ *
+ * Copyright (C) 2018, bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef DDR_DEFS_BAW_H
+#define DDR_DEFS_BAW_H
+
+/* Samsung K4B2G1646Q-BCK0 (256MB DDR3) */
+#define K4B2G1646QBCK0_EMIF_READ_LATENCY	0x100007
+#define K4B2G1646QBCK0_EMIF_TIM1		0x0AAAE51B
+#define K4B2G1646QBCK0_EMIF_TIM2		0x2A437FDA
+#define K4B2G1646QBCK0_EMIF_TIM3		0x501F83FF
+#define K4B2G1646QBCK0_EMIF_SDCFG		0x61C052B2
+#define K4B2G1646QBCK0_EMIF_SDREF		0x00000C30
+#define K4B2G1646QBCK0_ZQ_CFG			0x50074BE4
+#define K4B2G1646QBCK0_RATIO			0x80
+#define K4B2G1646QBCK0_INVERT_CLKOUT		0x0
+#define K4B2G1646QBCK0_RD_DQS			0x35
+#define K4B2G1646QBCK0_WR_DQS			0x3A
+#define K4B2G1646QBCK0_PHY_FIFO_WE		0x97
+#define K4B2G1646QBCK0_PHY_WR_DATA		0x76
+#define K4B2G1646QBCK0_IOCTRL_VALUE		0x18B
+
+/* Samsung K4B4G1646D-BIK0 (512MB DDR3) */
+#define K4B4G1646DBIK0_EMIF_READ_LATENCY	0x100007
+#define K4B4G1646DBIK0_EMIF_TIM1		0x0AAAE51B
+#define K4B4G1646DBIK0_EMIF_TIM2		0x2A6B7FDA
+#define K4B4G1646DBIK0_EMIF_TIM3		0x501F867F
+#define K4B4G1646DBIK0_EMIF_SDCFG		0x61C052B2
+#define K4B4G1646DBIK0_EMIF_SDREF		0x00000C30
+#define K4B4G1646DBIK0_ZQ_CFG			0x50074BE4
+#define K4B4G1646DBIK0_RATIO			0x80
+#define K4B4G1646DBIK0_INVERT_CLKOUT		0x0
+#define K4B4G1646DBIK0_RD_DQS			0x35
+#define K4B4G1646DBIK0_WR_DQS			0x3A
+#define K4B4G1646DBIK0_PHY_FIFO_WE		0x97
+#define K4B4G1646DBIK0_PHY_WR_DATA		0x76
+#define K4B4G1646DBIK0_IOCTRL_VALUE		0x18B
+
+/* Micron MT41K512M16HA-107 IT:A D9SGD (1024MB DDR3) */
+#define MT41K512M16HA107_EMIF_READ_LATENCY	0x100007
+#define MT41K512M16HA107_EMIF_TIM1		0x0AA15CA3
+#define MT41K512M16HA107_EMIF_TIM2		0x2A8F7FDA
+#define MT41K512M16HA107_EMIF_TIM3		0x501F88BF
+#define MT41K512M16HA107_EMIF_SDCFG		0x61C04BB2
+#define MT41K512M16HA107_EMIF_SDREF		0x0000093B
+#define MT41K512M16HA107_ZQ_CFG			0x50074BE4
+#define MT41K512M16HA107_RATIO			0x80
+#define MT41K512M16HA107_INVERT_CLKOUT		0x0
+#define MT41K512M16HA107_RD_DQS			0x35
+#define MT41K512M16HA107_WR_DQS			0x3A
+#define MT41K512M16HA107_PHY_FIFO_WE		0x79
+#define MT41K512M16HA107_PHY_WR_DATA		0x76
+#define MT41K512M16HA107_IOCTRL_VALUE		0x18B
+
+#endif
diff --git a/board/bytesatwork/byteengine_m2/m2config/README b/board/bytesatwork/byteengine_m2/m2config/README
new file mode 100644
index 0000000000..f82ef75ac3
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/README
@@ -0,0 +1,68 @@
+
+Configuration options:
+
+CONFIG_CMD_M2CONFIG
+If defined, add the u-boot command m2config to read and write the configuration.
+
+CONFIG_M2CONFIG_EEPROM
+If defined, add method to read (SPL) and write (SPL and u-boot) the
+configuration from the eeprom.
+
+CONFIG_M2CONFIG_BUILTIN
+If defined, add built-in configuration values. Define the following names:
+  M2CONFIG_BUILTIN_PCB
+  M2CONFIG_BUILTIN_RAM
+  M2CONFIG_BUILTIN_FLASH
+
+If both CONFIG_M2CONFIG_EEPROM and CONFIG_M2CONFIG_BUILTIN are defined, the
+order is defined in m2config_get.
+
+At least one of CONFIG_M2CONFIG_EEPROM or CONFIG_M2CONFIG_BUILTIN has to be
+defined.
+
+
+EEPROM format
+
+Byte order is the native byte order of the CPU. The format is:
+
+Bytes  Usage
+  2    Magic
+  2    length
+  4    PCB
+  4    RAM
+  4    Flash
+  4    CRC
+
+Magic is 0x6268. CRC is the native u-boot crc32.
+
+
+Extended data EEPROM format
+
+Byte order is the native byte order of the CPU. The format is:
+
+Bytes  Usage
+  2    Magic ext.
+  2    length
+  4    CRC
+  4    Article number
+  4    Lot
+  1    Lot sequence number
+ 12    Production date
+  6    Flash date
+  6    Flash user
+
+Magic is 0x6235. CRC is the native u-boot crc32.
+
+
+Tracking data EEPROM format
+
+Byte order is the native byte order of the CPU. The format is:
+
+Bytes  Usage
+  2    Magic (tracking data)
+  2    length
+  4    CRC
+ 18    MAC address
+ 16    UID
+
+Magic is 0x6e4a. CRC is the native u-boot crc32.
diff --git a/board/bytesatwork/byteengine_m2/m2config/cmd_m2config.c b/board/bytesatwork/byteengine_m2/m2config/cmd_m2config.c
new file mode 100644
index 0000000000..080df29aee
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/cmd_m2config.c
@@ -0,0 +1,220 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "m2config_builtin.h"
+#include "m2config_eeprom.h"
+
+static void print_config(const struct m2config *config)
+{
+	printf("PCB:   %u (%s)\n", config->pcb, m2config_get_pcb_name(config->pcb));
+	printf("RAM:   %u (%s)\n", config->ram, m2config_get_ram_name(config->ram));
+	printf("Flash: %u (%s)\n", config->flash, m2config_get_flash_name(config->flash));
+
+	if (config->ext_avail == 1) {
+		printf("\n");
+		printf("Article number:  %u\n", config->artno);
+		printf("Lot:             %u.%u\n", config->lot, config->lotseq);
+		printf("Production date: %s\n", config->proddate);
+		printf("Flash date:      %s\n", config->flashdate);
+		printf("Flash user:      %s\n", config->flashuser);
+	}
+
+	if (config->track_avail == 1) {
+		printf("\n");
+		printf("MAC address:     %s\n", config->macaddr);
+		printf("UID:             %s\n", config->uid);
+	}
+}
+
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+static enum command_ret_t cmd_builtin(int argc, char * const argv[])
+{
+	if (argc != 0)
+		return CMD_RET_USAGE;
+
+	struct m2config config;
+
+	if (m2config_builtin(&config) != 0) {
+		printf("could not get built-in configuration\n");
+		return CMD_RET_FAILURE;
+	}
+
+	print_config(&config);
+
+	return CMD_RET_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_M2CONFIG_EEPROM)
+static enum command_ret_t cmd_read(int argc, char * const argv[])
+{
+	struct m2config config;
+	int ret;
+
+	if (argc != 0)
+		return CMD_RET_USAGE;
+
+	ret = m2config_eeprom_read(&config);
+	if (ret != 0)
+		printf("no configuration in eeprom: %i\n", ret);
+	else
+		print_config(&config);
+
+	return CMD_RET_SUCCESS;
+}
+
+static enum command_ret_t cmd_write(int argc, char * const argv[])
+{
+	struct m2config config;
+
+	if (argc != 11)
+		return CMD_RET_USAGE;
+
+	config.pcb = simple_strtoul(argv[0], NULL, 10);
+	config.ram = simple_strtoul(argv[1], NULL, 10);
+	config.flash = simple_strtoul(argv[2], NULL, 10);
+
+	config.artno = simple_strtoul(argv[3], NULL, 10);
+	config.lot = simple_strtoul(argv[4], NULL, 10);
+	config.lotseq = simple_strtoul(argv[5], NULL, 10);
+	strlcpy(config.proddate, argv[6], sizeof(config.proddate));
+	strlcpy(config.flashdate, argv[7], sizeof(config.flashdate));
+	strlcpy(config.flashuser, argv[8], sizeof(config.flashuser));
+
+	strlcpy(config.macaddr, argv[9], sizeof(config.macaddr));
+	strlcpy(config.uid, argv[10], sizeof(config.uid));
+
+	if (m2config_eeprom_write(&config) != 0) {
+		printf("could not write to EEPROM\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+static enum command_ret_t cmd_erase(int argc, char * const argv[])
+{
+	if (argc != 0)
+		return CMD_RET_USAGE;
+
+	if (m2config_eeprom_erase() != 0) {
+		printf("could not erase configuration\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+static enum command_ret_t cmd_builtin2eeprom(int argc, char * const argv[])
+{
+	if (argc != 0)
+		return CMD_RET_USAGE;
+
+	struct m2config config;
+
+	if (m2config_builtin(&config) != 0) {
+		printf("could not get built-in configuration\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (m2config_eeprom_write(&config) != 0) {
+		printf("could not write to EEPROM\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+#endif
+#endif
+
+struct m2config_cmd_struct {
+		char  *name;
+		enum command_ret_t (*func)(int argc, char * const argv[]);
+};
+
+static const struct m2config_cmd_struct m2config_cmd[] = {
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+	{ "builtin", cmd_builtin },
+#endif
+#if defined(CONFIG_M2CONFIG_EEPROM)
+	{ "read", cmd_read },
+	{ "erase", cmd_erase },
+	{ "write", cmd_write },
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+	{ "builtin2eeprom", cmd_builtin2eeprom },
+#endif
+#endif
+	{ NULL, NULL }
+};
+
+static const struct m2config_cmd_struct *findCmd(const char *name)
+{
+	const struct m2config_cmd_struct *cmd;
+
+	for (cmd = m2config_cmd; cmd->name != NULL; cmd++)
+		if (strcmp (name, cmd->name) == 0)
+			return cmd;
+
+	return NULL;
+}
+
+static void print_config_names(const struct m2config_name_pair *map)
+{
+	const struct m2config_name_pair *itr;
+
+	for (itr = map; itr->name != NULL; itr++)
+		printf("  %u (%s)\n", itr->config, itr->name);
+}
+
+static enum command_ret_t print_configurations(void)
+{
+	printf("PCB:\n");
+	print_config_names(m2config_pcb_name);
+	printf("RAM:\n");
+	print_config_names(m2config_ram_name);
+	printf("Flash:\n");
+	print_config_names(m2config_flash_name);
+
+	return CMD_RET_SUCCESS;
+}
+
+enum command_ret_t do_m2config(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	if (argc >= 2) {
+		const struct m2config_cmd_struct *cmd = findCmd(argv[1]);
+
+		if (cmd != NULL)
+			return cmd->func(argc-2, &argv[2]);
+		else
+			return CMD_RET_USAGE;
+	}
+
+	return print_configurations();
+}
+
+U_BOOT_CMD(
+	m2config, 13, 0, do_m2config,
+	"perform m2 configuration",
+	"- list known configuration values\n"
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+	"builtin  - print built-in configuration from u-boot\n"
+#endif
+#if defined(CONFIG_M2CONFIG_EEPROM)
+	"read     - read configuration from EEPROM\n"
+	"erase    - erase configuration from EEPROM\n"
+	"write <PCB> <RAM> <Flash>\n"
+	"         - write configuration to EEPROM\n"
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+	"builtin2eeprom\n"
+	"         - write built-in configuration to EEPROM\n"
+#endif
+#endif
+);
diff --git a/board/bytesatwork/byteengine_m2/m2config/m2config.c b/board/bytesatwork/byteengine_m2/m2config/m2config.c
new file mode 100644
index 0000000000..ddbb63d9f5
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/m2config.c
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "m2config.h"
+
+const struct m2config_name_pair m2config_pcb_name[] = {
+	{ M2_PCB_REV_00, "Rev.00" },
+	{ M2_PCB_REV_01, "Rev.01" },
+	{ M2_PCB_REV_02, "Rev.02" },
+	{ M2_PCB_REV_03, "Rev.03" },
+	{ M2_PCB_REV_04, "Rev.04" },
+	{ -1, NULL },
+};
+
+const struct m2config_name_pair m2config_ram_name[] = {
+	{ M2_RAM_MT47H128M16RT25E, "MT47H128M16RT25E 256 MB DDR2 @ 266MHz" },
+	{ M2_RAM_K4B2G1646EBIH9,   "K4B2G1646EBIH9 legacy DDR3 @ 303MHz" },
+	{ M2_RAM_K4B2G1646QBCK0,   "K4B2G1646QBCK0 256 MB DDR3 @ 400Mhz" },
+	{ M2_RAM_K4B4G1646DBIK0,   "K4B4G1646DBIK0 512 MB DDR3 @ 400MHz" },
+	{ M2_RAM_MT41K512M16HA107, "MT41K512M16HA107 1024MB DDR3 @ 303MHz" },
+	{ -1, NULL },
+};
+
+const struct m2config_name_pair m2config_flash_name[] = {
+	{ M2_NAND_2GBIT, "Nand 2 GBit" },
+	{ M2_NAND_4GBIT, "Nand 4 GBit" },
+	{ M2_EMMC_4GB, "EMMC 4 GB" },
+	{ M2_EMMC_8GB, "EMMC 8 GB" },
+	{ M2_EMMC_16GB, "EMMC 16 GB" },
+	{ M2_EMMC_32GB, "EMMC 32 GB" },
+	{ -1, NULL },
+};
+
+const char *m2config_get_name(uint32_t config, const struct m2config_name_pair *map)
+{
+	const struct m2config_name_pair *itr;
+
+	for (itr = map; itr->name != NULL; itr++)
+		if (itr->config == config)
+			return itr->name;
+
+	return "unknown";
+}
diff --git a/board/bytesatwork/byteengine_m2/m2config/m2config.h b/board/bytesatwork/byteengine_m2/m2config/m2config.h
new file mode 100644
index 0000000000..6e84f79477
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/m2config.h
@@ -0,0 +1,81 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef M2CONFIG_H
+#define M2CONFIG_H
+
+#include <config.h>
+#include <linux/types.h>
+
+typedef enum {
+	M2_PCB_REV_00 = 0,
+	M2_PCB_REV_01 = 1,
+	M2_PCB_REV_02 = 2,
+	M2_PCB_REV_03 = 3,
+	M2_PCB_REV_04 = 4,
+} m2config_pcb_t;
+
+typedef enum {
+	M2_RAM_MT47H128M16RT25E = 1,
+	M2_RAM_K4B2G1646EBIH9   = 2,
+	M2_RAM_K4B2G1646QBCK0   = 3,
+	M2_RAM_K4B4G1646DBIK0   = 4,
+	M2_RAM_MT41K512M16HA107 = 5,
+} m2config_ram_t;
+
+typedef enum {
+	M2_NAND_2GBIT  = 0,
+	M2_NAND_4GBIT  = 1,
+	M2_EMMC_4GB  = 2,
+	M2_EMMC_8GB  = 3,
+	M2_EMMC_16GB = 4,
+	M2_EMMC_32GB = 5,
+} m2config_flash_t;
+
+struct m2config {
+	m2config_pcb_t		pcb;
+	m2config_ram_t		ram;
+	m2config_flash_t	flash;
+	bool			ext_avail;
+	uint32_t		artno;
+	uint32_t		lot;
+	uint8_t			lotseq;
+	char			proddate[12];
+	char			flashdate[6];
+	char			flashuser[6];
+	bool			track_avail;
+	char			macaddr[18];
+	char			uid[16];
+};
+
+struct m2config_name_pair {
+	uint32_t	config;
+	const char	*name;
+};
+
+extern const struct m2config_name_pair m2config_pcb_name[];
+extern const struct m2config_name_pair m2config_ram_name[];
+extern const struct m2config_name_pair m2config_flash_name[];
+
+const char *m2config_get_name(uint32_t config, const struct m2config_name_pair *map);
+
+static inline const char *m2config_get_pcb_name(m2config_pcb_t config)
+{
+	return m2config_get_name(config, m2config_pcb_name);
+}
+
+static inline const char *m2config_get_ram_name(m2config_ram_t config)
+{
+	return m2config_get_name(config, m2config_ram_name);
+}
+
+static inline const char *m2config_get_flash_name(m2config_flash_t config)
+{
+	return m2config_get_name(config, m2config_flash_name);
+}
+
+#endif
diff --git a/board/bytesatwork/byteengine_m2/m2config/m2config_builtin.c b/board/bytesatwork/byteengine_m2/m2config/m2config_builtin.c
new file mode 100644
index 0000000000..932e5eb37f
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/m2config_builtin.c
@@ -0,0 +1,17 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "m2config.h"
+#include <config.h>
+
+int m2config_builtin(struct m2config *config)
+{
+	config->pcb    = M2CONFIG_BUILTIN_PCB;
+	config->ram    = M2CONFIG_BUILTIN_RAM;
+	config->flash  = M2CONFIG_BUILTIN_FLASH;
+	return 0;
+}
diff --git a/board/bytesatwork/byteengine_m2/m2config/m2config_builtin.h b/board/bytesatwork/byteengine_m2/m2config/m2config_builtin.h
new file mode 100644
index 0000000000..e41bf7bf88
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/m2config_builtin.h
@@ -0,0 +1,23 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef M2CONFIG_BUILTIN_H
+#define M2CONFIG_BUILTIN_H
+
+#include "m2config.h"
+#include <config.h>
+
+#if defined(M2CONFIG_BUILTIN)
+int m2config_builtin(struct m2config *config);
+#else
+static inline int m2config_builtin(struct m2config *config)
+{
+	return -1;
+}
+#endif
+
+#endif
diff --git a/board/bytesatwork/byteengine_m2/m2config/m2config_eeprom.c b/board/bytesatwork/byteengine_m2/m2config/m2config_eeprom.c
new file mode 100644
index 0000000000..d283d42562
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/m2config_eeprom.c
@@ -0,0 +1,238 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "m2config_eeprom.h"
+
+#include "m2config.h"
+
+#include <common.h>
+#include <i2c.h>
+
+#define EEPROM_ADDRESS	0x50
+#define EEPROM_MAXWRITE	64	/* max. page size for writes */
+#define MAGIC  0x6268
+#define EEPROM_EXT_OFFSET 0x14
+#define MAGIC_EXT 0x6235
+#define EEPROM_TRACK_OFFSET 0x3d
+#define MAGIC_TRACK 0x6e4a
+
+struct eeprom_header {
+	uint16_t magic;
+	uint16_t length;
+} __attribute__ ((packed));
+
+struct eeprom_content {
+	uint32_t	pcb;
+	uint32_t	ram;
+	uint32_t	flash;
+} __attribute__ ((packed));
+
+struct eeprom_content_ext {
+	uint32_t	artno;
+	uint32_t	lot;
+	uint8_t		lotseq;
+	char		proddate[12];
+	char		flashdate[6];
+	char		flashuser[6];
+} __attribute__ ((packed));
+
+struct eeprom_content_track {
+	char		macaddr[18];
+	char		uid[16];	/* enable use of characters */
+} __attribute__ ((packed));
+
+struct eeprom_data {
+	struct eeprom_header	header;
+	struct eeprom_content	content;
+	uint32_t		crc;
+} __attribute__ ((packed));
+
+struct eeprom_data_ext {
+	struct eeprom_header		header;
+	uint32_t			crc;
+	struct eeprom_content_ext	content;
+} __attribute__ ((packed));
+
+struct eeprom_data_track {
+	struct eeprom_header		header;
+	uint32_t			crc;
+	struct eeprom_content_track	content;
+} __attribute__ ((packed));
+
+struct eeprom_write_frame {
+	struct eeprom_data		content;
+	struct eeprom_data_ext		content_ext;
+	struct eeprom_data_track	content_track;
+} __attribute__ ((packed));
+
+struct eeprom_read_frame {
+	struct eeprom_data		content;
+	struct eeprom_data_ext		content_ext;
+	struct eeprom_data_track	content_track;
+} __attribute__ ((packed));
+
+static int i2c_write_rdy(void)
+{
+	/*
+	 * Check if device is ready for write to eeprom. Write can last up to
+	 * 5 ms. Poll with empty write.
+	 */
+	int i, ret = -5;
+	uint8_t dummy = 0xff;	/* i2c_write doesn't like to write NULL pointers */
+
+	for (i = 0; ret < 0 && i < 10; ++i) {
+		if (i2c_write(EEPROM_ADDRESS, 0, 2, &dummy, 0) != 0) {
+			udelay(500);
+		} else {
+			ret = 0;
+			break;
+		}
+	}
+	if (ret)
+		printf("Error: eeprom busy, giving up.\n");
+
+	return ret;
+}
+
+int i2c_long_write(struct eeprom_write_frame frame, int len)
+{
+	int wlen, off = 0;
+
+	while (len > 0) {
+		if (len >= EEPROM_MAXWRITE)
+			wlen = EEPROM_MAXWRITE;
+		else
+			wlen = len;
+		if (i2c_write_rdy() || i2c_write(EEPROM_ADDRESS, off, 2, (uint8_t *)(&frame) + off, wlen) != 0)
+			return -30;
+		len -= wlen;
+		off += wlen;
+	}
+
+	return 0;
+}
+
+int m2config_eeprom_read(struct m2config *config)
+{
+	struct eeprom_read_frame frame;
+
+	if (i2c_read(EEPROM_ADDRESS, 0, 2, (uint8_t *)&frame, sizeof(frame)) != 0)
+		return -3;
+
+	if (frame.content.header.magic != MAGIC)
+		return -4;
+
+	if (frame.content.header.length != sizeof(frame.content.content))
+		return -5;
+
+	/* Cast crc32 value to uint8_t because of legacy code */
+	if (frame.content.crc != (uint8_t)crc32(0, (uint8_t *)&frame.content.content, sizeof(frame.content.content)))
+		return -6;
+
+	config->pcb    = frame.content.content.pcb;
+	config->ram    = frame.content.content.ram;
+	config->flash  = frame.content.content.flash;
+
+	config->ext_avail = 0;
+	if (frame.content_ext.header.magic != MAGIC_EXT) {
+		printf("ext magic wrong\n");
+		return 0;
+	}
+
+	if (frame.content_ext.header.length != sizeof(frame.content_ext.content)) {
+		printf("ext len wrong\n");
+		return 0;
+	}
+
+	if (frame.content_ext.crc != crc32(0, (uint8_t *)&frame.content_ext.content, sizeof(frame.content_ext.content))) {
+		printf("ext crc wrong\n");
+		return 0;
+	}
+
+	config->artno = frame.content_ext.content.artno;
+	config->lot = frame.content_ext.content.lot;
+	config->lotseq = frame.content_ext.content.lotseq;
+
+	strlcpy(config->proddate, frame.content_ext.content.proddate, sizeof(config->proddate));
+	strlcpy(config->flashdate, frame.content_ext.content.flashdate, sizeof(config->flashdate));
+	strlcpy(config->flashuser, frame.content_ext.content.flashuser, sizeof(config->flashuser));
+
+	config->ext_avail = 1;
+
+	config->track_avail = 0;
+	if (frame.content_track.header.magic != MAGIC_TRACK) {
+		printf("track magic wrong\n");
+		return 0;
+	}
+
+	if (frame.content_track.header.length != sizeof(frame.content_track.content)) {
+		printf("track len wrong\n");
+		return 0;
+	}
+
+	if (frame.content_track.crc != crc32(0, (uint8_t *)&frame.content_track.content, sizeof(frame.content_track.content))) {
+		printf("track crc wrong\n");
+		return 0;
+	}
+
+	strlcpy(config->macaddr, frame.content_track.content.macaddr, sizeof(config->macaddr));
+	strlcpy(config->uid, frame.content_track.content.uid, sizeof(config->uid));
+
+	config->track_avail = 1;
+
+	return 0;
+}
+
+#if defined(CONFIG_SKIP_LOWLEVEL_INIT)
+
+int m2config_eeprom_write(struct m2config *config)
+{
+	struct eeprom_write_frame   frame;
+
+	frame.content.header.magic = MAGIC;
+	frame.content.header.length = sizeof(frame.content.content);
+	frame.content.content.pcb = config->pcb;
+	frame.content.content.ram = config->ram;
+	frame.content.content.flash = config->flash;
+	/* Cast crc32 value to uint8_t because of legacy code */
+	frame.content.crc = (uint8_t)crc32(0, (const uint8_t *)&frame.content.content, sizeof(frame.content.content));
+
+	frame.content_ext.header.magic = MAGIC_EXT;
+	frame.content_ext.header.length = sizeof(frame.content_ext.content);
+	frame.content_ext.content.artno = config->artno;
+	frame.content_ext.content.lot = config->lot;
+	frame.content_ext.content.lotseq = config->lotseq;
+	strlcpy(frame.content_ext.content.proddate, config->proddate, sizeof(frame.content_ext.content.proddate));
+	strlcpy(frame.content_ext.content.flashdate, config->flashdate, sizeof(frame.content_ext.content.flashdate));
+	strlcpy(frame.content_ext.content.flashuser, config->flashuser, sizeof(frame.content_ext.content.flashuser));
+	frame.content_ext.crc = crc32(0, (uint8_t *)&frame.content_ext.content, sizeof(frame.content_ext.content));
+
+	frame.content_track.header.magic = MAGIC_TRACK;
+	frame.content_track.header.length = sizeof(frame.content_track.content);
+	strlcpy(frame.content_track.content.macaddr, config->macaddr, sizeof(frame.content_track.content.macaddr));
+	strlcpy(frame.content_track.content.uid, config->uid, sizeof(frame.content_track.content.uid));
+	frame.content_track.crc = crc32(0, (uint8_t *)&frame.content_track.content, sizeof(frame.content_track.content));
+
+	if (i2c_long_write(frame, sizeof(frame)) != 0)
+		return -7;
+
+	return 0;
+}
+
+int m2config_eeprom_erase(void)
+{
+	struct eeprom_write_frame   frame;
+
+	memset(&frame, 0xff, sizeof(frame));
+
+	if (i2c_long_write(frame, sizeof(frame)) != 0)
+		return -8;
+
+	return 0;
+}
+
+#endif
diff --git a/board/bytesatwork/byteengine_m2/m2config/m2config_eeprom.h b/board/bytesatwork/byteengine_m2/m2config/m2config_eeprom.h
new file mode 100644
index 0000000000..7bcba7d3e9
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/m2config_eeprom.h
@@ -0,0 +1,38 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef M2CONFIG_EEPROM_H
+#define M2CONFIG_EEPROM_H
+
+#include "m2config.h"
+#include <config.h>
+
+#if defined(CONFIG_M2CONFIG_EEPROM)
+int m2config_eeprom_read(struct m2config *config);
+#else
+static inline int m2config_eeprom_read(struct m2config *config)
+{
+	return -1;
+}
+#endif
+
+#if defined(CONFIG_M2CONFIG_EEPROM) && defined(CONFIG_SKIP_LOWLEVEL_INIT)
+int m2config_eeprom_write(struct m2config *config);
+int m2config_eeprom_erase(void);
+#else
+static inline int m2config_eeprom_write(struct m2config *config)
+{
+	return -1;
+}
+
+static inline int m2config_eeprom_erase(void)
+{
+	return -1;
+}
+#endif
+
+#endif
diff --git a/board/bytesatwork/byteengine_m2/m2config/m2config_get.c b/board/bytesatwork/byteengine_m2/m2config/m2config_get.c
new file mode 100644
index 0000000000..3f405fca75
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/m2config_get.c
@@ -0,0 +1,38 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/ddr_defs.h>
+#include <i2c.h>
+#include "m2config_get.h"
+
+#include "m2config_builtin.h"
+#include "m2config_eeprom.h"
+
+#define PMIC_ADDRESS 0x2D
+
+void m2config_get(struct m2config *config)
+{
+	uint8_t reg = 0;
+
+	if (m2config_eeprom_read(config) == 0)
+		return;
+
+	if (i2c_read(PMIC_ADDRESS, 0x20, 1, &reg, 1) != 0) {
+		printf("Error: PMIC read failed\n");
+	}
+
+	if (reg == 0x05) {
+		config->ram = M2_RAM_MT47H128M16RT25E;	/* set DDR2 */
+		printf("DDR2 detected\n");
+	} else if (reg == 0x01) {
+		config->ram = M2_RAM_K4B2G1646EBIH9;	/* set legacy DDR3 */
+		printf("DDR3 detected\n");
+	} else {
+		config->ram = M2_RAM_K4B2G1646EBIH9;	/* set default to legacy DDR3 */
+		printf("Error: no RAM configuration found, trying fallback configuration %u\n", config->ram);
+	}
+}
diff --git a/board/bytesatwork/byteengine_m2/m2config/m2config_get.h b/board/bytesatwork/byteengine_m2/m2config/m2config_get.h
new file mode 100644
index 0000000000..56fcfd417e
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/m2config/m2config_get.h
@@ -0,0 +1,15 @@
+/*
+ * (C) Copyright 2015
+ * bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef M2CONFIG_GET_H
+#define M2CONFIG_GET_H
+
+#include "m2config.h"
+
+void m2config_get(struct m2config *config);
+
+#endif
diff --git a/board/bytesatwork/byteengine_m2/mux.c b/board/bytesatwork/byteengine_m2/mux.c
new file mode 100644
index 0000000000..587dc43ec7
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/mux.c
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on board/ti/am335x/mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "board.h"
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+#ifdef CONFIG_TARGET_BYTEENGINE_M2_REV4
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad7), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT7 */
+	{OFFSET(gpmc_ad6), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT6 */
+	{OFFSET(gpmc_ad5), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT5 */
+	{OFFSET(gpmc_ad4), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT4 */
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{-1},
+};
+#else
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD0 */
+	{OFFSET(gpmc_ad1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD1 */
+	{OFFSET(gpmc_ad2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD2 */
+	{OFFSET(gpmc_ad3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD3 */
+	{OFFSET(gpmc_ad4), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD4 */
+	{OFFSET(gpmc_ad5), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD5 */
+	{OFFSET(gpmc_ad6), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD6 */
+	{OFFSET(gpmc_ad7), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD7 */
+	{OFFSET(gpmc_wpn), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPMC_WPN */
+	{OFFSET(gpmc_csn0), (MODE(0))},				/* GPMC_CSN0 */
+	{OFFSET(gpmc_advn_ale), (MODE(0))},			/* GPMC_ADVN_ALE */
+	{OFFSET(gpmc_be0n_cle), (MODE(0))},			/* GPMC_BEN0_CLE */
+	{OFFSET(gpmc_wen), (MODE(0))},				/* GPMC_WEN */
+	{OFFSET(gpmc_oen_ren), (MODE(0))},			/* GPMC_OEN_REN */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_WAIT0 */
+	{-1},
+};
+#endif
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},   /* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},                 /* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},     /* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},                 /* SPI0_CS0 */
+	{-1},
+};
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+void enable_board_pin_mux(void)
+{
+	configure_module_pin_mux(mii1_pin_mux);
+	configure_module_pin_mux(spi0_pin_mux);
+
+#ifdef CONFIG_SPL_BUILD		/* no driver model (DM) support in SPL yet */
+	configure_module_pin_mux(mmc0_pin_mux);
+#ifdef CONFIG_TARGET_BYTEENGINE_M2_REV4
+	configure_module_pin_mux(mmc1_pin_mux);
+#endif
+#endif
+
+#ifdef CONFIG_TARGET_BYTEENGINE_M2
+	configure_module_pin_mux(nand_pin_mux);
+#endif
+}
diff --git a/board/bytesatwork/byteengine_m2/ram.c b/board/bytesatwork/byteengine_m2/ram.c
new file mode 100644
index 0000000000..cc44b69bb2
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/ram.c
@@ -0,0 +1,354 @@
+/*
+ * RAM initialization for byteENGINE M2
+ *
+ * Copyright (C) 2015 bytes at work AG
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch-am33xx/clock.h>
+#include <i2c.h>
+#include <config.h>
+#include "board.h"
+#include "ddr_defs_baw.h"
+#include "m2config/m2config.h"
+#include "m2config/m2config_get.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define OSC	(V_OSCK / 1000000)
+
+/* 256 MB DDR2 -------------------------------------------------------------- */
+
+static const struct ctrl_ioregs MT47H128M16RT25E_ctrl_ioregs = {
+	.cm0ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.cm1ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.cm2ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.dt0ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.dt1ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+};
+
+static const struct ddr_data MT47H128M16RT25E_ddr_data = {
+	.datardsratio0		= MT47H128M16RT25E_RD_DQS,
+	.datafwsratio0		= MT47H128M16RT25E_PHY_FIFO_WE,
+	.datawrsratio0		= MT47H128M16RT25E_PHY_WR_DATA,
+};
+
+static const struct cmd_control MT47H128M16RT25E_cmd_control = {
+	.cmd0csratio		= MT47H128M16RT25E_RATIO,
+	.cmd1csratio		= MT47H128M16RT25E_RATIO,
+	.cmd2csratio		= MT47H128M16RT25E_RATIO,
+};
+
+static const struct emif_regs MT47H128M16RT25E_emif_regs = {
+	.sdram_config		= MT47H128M16RT25E_EMIF_SDCFG,
+	.ref_ctrl		= MT47H128M16RT25E_EMIF_SDREF,
+	.sdram_tim1		= MT47H128M16RT25E_EMIF_TIM1,
+	.sdram_tim2		= MT47H128M16RT25E_EMIF_TIM2,
+	.sdram_tim3		= MT47H128M16RT25E_EMIF_TIM3,
+	.emif_ddr_phy_ctlr_1	= MT47H128M16RT25E_EMIF_READ_LATENCY,
+};
+
+#define MT47H128M16RT25E_CLOCK_MHZ	266
+
+static void init_MT47H128M16RT25E(void)
+{
+	config_ddr(MT47H128M16RT25E_CLOCK_MHZ,
+		&MT47H128M16RT25E_ctrl_ioregs,
+		&MT47H128M16RT25E_ddr_data,
+		&MT47H128M16RT25E_cmd_control,
+		&MT47H128M16RT25E_emif_regs,
+		0);
+}
+
+static const struct dpll_params MT47H128M16RT25E_dpll = {
+	MT47H128M16RT25E_CLOCK_MHZ, OSC-1,
+	1, -1, -1, -1, -1
+};
+
+/* DDR3 256 and 512 MB Legacy setting due to wrong programmed modules config 2 */
+
+static const struct ctrl_ioregs K4B2G1646EBIH9_ctrl_ioregs = {
+	.cm0ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+	.cm1ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+	.cm2ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+	.dt0ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+	.dt1ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+};
+
+static const struct ddr_data K4B2G1646EBIH9_ddr_data = {
+	.datardsratio0		= K4B2G1646EBIH9_RD_DQS,
+	.datawdsratio0		= K4B2G1646EBIH9_WR_DQS,
+	.datafwsratio0		= K4B2G1646EBIH9_PHY_FIFO_WE,
+	.datawrsratio0		= K4B2G1646EBIH9_PHY_WR_DATA,
+};
+
+static const struct cmd_control K4B2G1646EBIH9_cmd_control = {
+	.cmd0csratio		= K4B2G1646EBIH9_RATIO,
+	.cmd0iclkout		= K4B2G1646EBIH9_INVERT_CLKOUT,
+
+	.cmd1csratio		= K4B2G1646EBIH9_RATIO,
+	.cmd1iclkout		= K4B2G1646EBIH9_INVERT_CLKOUT,
+
+	.cmd2csratio		= K4B2G1646EBIH9_RATIO,
+	.cmd2iclkout		= K4B2G1646EBIH9_INVERT_CLKOUT,
+};
+
+static const struct emif_regs K4B2G1646EBIH9_emif_regs = {
+	.sdram_config		= K4B2G1646EBIH9_EMIF_SDCFG,
+	.ref_ctrl		= K4B2G1646EBIH9_EMIF_SDREF,
+	.sdram_tim1		= K4B2G1646EBIH9_EMIF_TIM1,
+	.sdram_tim2		= K4B2G1646EBIH9_EMIF_TIM2,
+	.sdram_tim3		= K4B2G1646EBIH9_EMIF_TIM3,
+	.zq_config		= K4B2G1646EBIH9_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1	= K4B2G1646EBIH9_EMIF_READ_LATENCY,
+};
+
+#define K4B2G1646EBIH9_CLOCK_MHZ	303
+
+static void init_K4B2G1646EBIH9(void)
+{
+	config_ddr(K4B2G1646EBIH9_CLOCK_MHZ,
+		&K4B2G1646EBIH9_ctrl_ioregs,
+		&K4B2G1646EBIH9_ddr_data,
+		&K4B2G1646EBIH9_cmd_control,
+		&K4B2G1646EBIH9_emif_regs,
+		0);
+
+	mdelay(2);
+}
+
+static const struct dpll_params K4B2G1646EBIH9_dpll = {
+	K4B2G1646EBIH9_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* DDR3 256 MB K4B2G1646Q-BCK0 ----------------------------------------------- */
+
+static const struct ctrl_ioregs K4B2G1646QBCK0_ctrl_ioregs = {
+	.cm0ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+	.cm1ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+	.cm2ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+	.dt0ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+	.dt1ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+};
+
+static const struct ddr_data K4B2G1646QBCK0_ddr_data = {
+	.datardsratio0		= K4B2G1646QBCK0_RD_DQS,
+	.datawdsratio0		= K4B2G1646QBCK0_WR_DQS,
+	.datafwsratio0		= K4B2G1646QBCK0_PHY_FIFO_WE,
+	.datawrsratio0		= K4B2G1646QBCK0_PHY_WR_DATA,
+};
+
+static const struct cmd_control K4B2G1646QBCK0_cmd_control = {
+	.cmd0csratio		= K4B2G1646QBCK0_RATIO,
+	.cmd0iclkout		= K4B2G1646QBCK0_INVERT_CLKOUT,
+
+	.cmd1csratio		= K4B2G1646QBCK0_RATIO,
+	.cmd1iclkout		= K4B2G1646QBCK0_INVERT_CLKOUT,
+
+	.cmd2csratio		= K4B2G1646QBCK0_RATIO,
+	.cmd2iclkout		= K4B2G1646QBCK0_INVERT_CLKOUT,
+};
+
+static const struct emif_regs K4B2G1646QBCK0_emif_regs = {
+	.sdram_config		= K4B2G1646QBCK0_EMIF_SDCFG,
+	.ref_ctrl		= K4B2G1646QBCK0_EMIF_SDREF,
+	.sdram_tim1		= K4B2G1646QBCK0_EMIF_TIM1,
+	.sdram_tim2		= K4B2G1646QBCK0_EMIF_TIM2,
+	.sdram_tim3		= K4B2G1646QBCK0_EMIF_TIM3,
+	.zq_config		= K4B2G1646QBCK0_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1	= K4B2G1646QBCK0_EMIF_READ_LATENCY,
+};
+
+#define K4B2G1646QBCK0_CLOCK_MHZ	400
+
+static void init_K4B2G1646QBCK0(void)
+{
+	config_ddr(K4B2G1646QBCK0_CLOCK_MHZ,
+		&K4B2G1646QBCK0_ctrl_ioregs,
+		&K4B2G1646QBCK0_ddr_data,
+		&K4B2G1646QBCK0_cmd_control,
+		&K4B2G1646QBCK0_emif_regs,
+		0);
+
+	mdelay(2);
+}
+
+static const struct dpll_params K4B2G1646QBCK0_dpll = {
+	K4B2G1646QBCK0_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* DDR3 512MB K4B4G1646D------------------------------------------------------ */
+static const struct ctrl_ioregs K4B4G1646DBIK0_ctrl_ioregs = {
+	.cm0ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+	.cm1ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+	.cm2ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+	.dt0ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+	.dt1ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+};
+
+static const struct ddr_data K4B4G1646DBIK0_ddr_data = {
+	.datardsratio0		= K4B4G1646DBIK0_RD_DQS,
+	.datawdsratio0		= K4B4G1646DBIK0_WR_DQS,
+	.datafwsratio0		= K4B4G1646DBIK0_PHY_FIFO_WE,
+	.datawrsratio0		= K4B4G1646DBIK0_PHY_WR_DATA,
+};
+
+static const struct cmd_control K4B4G1646DBIK0_cmd_control = {
+	.cmd0csratio		= K4B4G1646DBIK0_RATIO,
+	.cmd0iclkout		= K4B4G1646DBIK0_INVERT_CLKOUT,
+
+	.cmd1csratio		= K4B4G1646DBIK0_RATIO,
+	.cmd1iclkout		= K4B4G1646DBIK0_INVERT_CLKOUT,
+
+	.cmd2csratio		= K4B4G1646DBIK0_RATIO,
+	.cmd2iclkout		= K4B4G1646DBIK0_INVERT_CLKOUT,
+};
+
+static const struct emif_regs K4B4G1646DBIK0_emif_regs = {
+	.sdram_config		= K4B4G1646DBIK0_EMIF_SDCFG,
+	.ref_ctrl		= K4B4G1646DBIK0_EMIF_SDREF,
+	.sdram_tim1		= K4B4G1646DBIK0_EMIF_TIM1,
+	.sdram_tim2		= K4B4G1646DBIK0_EMIF_TIM2,
+	.sdram_tim3		= K4B4G1646DBIK0_EMIF_TIM3,
+	.zq_config		= K4B4G1646DBIK0_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1	= K4B4G1646DBIK0_EMIF_READ_LATENCY,
+};
+
+#define K4B4G1646DBIK0_CLOCK_MHZ	400
+
+static void init_K4B4G1646DBIK0(void)
+{
+	config_ddr(K4B4G1646DBIK0_CLOCK_MHZ,
+		&K4B4G1646DBIK0_ctrl_ioregs,
+		&K4B4G1646DBIK0_ddr_data,
+		&K4B4G1646DBIK0_cmd_control,
+		&K4B4G1646DBIK0_emif_regs,
+		0);
+
+	mdelay(2);
+}
+
+static const struct dpll_params K4B4G1646DBIK0_dpll = {
+	K4B4G1646DBIK0_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* DDR3 1024MB MT41K512M16HA-107 IT:A 	D9SGD --------------------------------*/
+
+static const struct ctrl_ioregs MT41K512M16HA107_ctrl_ioregs = {
+	.cm0ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+	.cm1ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+	.cm2ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+	.dt0ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+	.dt1ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+};
+
+static const struct ddr_data MT41K512M16HA107_ddr_data = {
+	.datardsratio0		= MT41K512M16HA107_RD_DQS,
+	.datawdsratio0		= MT41K512M16HA107_WR_DQS,
+	.datafwsratio0		= MT41K512M16HA107_PHY_FIFO_WE,
+	.datawrsratio0		= MT41K512M16HA107_PHY_WR_DATA,
+};
+
+static const struct cmd_control MT41K512M16HA107_cmd_control = {
+	.cmd0csratio		= MT41K512M16HA107_RATIO,
+	.cmd0iclkout		= MT41K512M16HA107_INVERT_CLKOUT,
+
+	.cmd1csratio		= MT41K512M16HA107_RATIO,
+	.cmd1iclkout		= MT41K512M16HA107_INVERT_CLKOUT,
+
+	.cmd2csratio		= MT41K512M16HA107_RATIO,
+	.cmd2iclkout		= MT41K512M16HA107_INVERT_CLKOUT,
+};
+
+static const struct emif_regs MT41K512M16HA107_emif_regs = {
+	.sdram_config		= MT41K512M16HA107_EMIF_SDCFG,
+	.ref_ctrl		= MT41K512M16HA107_EMIF_SDREF,
+	.sdram_tim1		= MT41K512M16HA107_EMIF_TIM1,
+	.sdram_tim2		= MT41K512M16HA107_EMIF_TIM2,
+	.sdram_tim3		= MT41K512M16HA107_EMIF_TIM3,
+	.zq_config		= MT41K512M16HA107_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1	= MT41K512M16HA107_EMIF_READ_LATENCY,
+};
+
+#define MT41K512M16HA107_CLOCK_MHZ 303
+
+static void init_MT41K512M16HA107(void)
+{
+	config_ddr(MT41K512M16HA107_CLOCK_MHZ,
+		&MT41K512M16HA107_ctrl_ioregs,
+		&MT41K512M16HA107_ddr_data,
+		&MT41K512M16HA107_cmd_control,
+		&MT41K512M16HA107_emif_regs,
+		0);
+
+	mdelay(2);
+}
+
+static const struct dpll_params MT41K512M16HA107_dpll = {
+	MT41K512M16HA107_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* --------------------------------------------------------------------------- */
+
+struct ram_config {
+	m2config_ram_t	config;
+	void (*init)(void);
+	const struct dpll_params *dpll_param;
+};
+
+const struct ram_config ram_init_map[] = {
+	{ M2_RAM_MT47H128M16RT25E, init_MT47H128M16RT25E, &MT47H128M16RT25E_dpll },
+	{ M2_RAM_K4B2G1646EBIH9,   init_K4B2G1646EBIH9,   &K4B2G1646EBIH9_dpll },
+	{ M2_RAM_K4B2G1646QBCK0,   init_K4B2G1646QBCK0,   &K4B2G1646QBCK0_dpll },
+	{ M2_RAM_K4B4G1646DBIK0,   init_K4B4G1646DBIK0,   &K4B4G1646DBIK0_dpll },
+	{ M2_RAM_MT41K512M16HA107,   init_MT41K512M16HA107,   &MT41K512M16HA107_dpll },
+	{ -1, NULL }
+};
+
+static const struct ram_config *findRam(m2config_ram_t config)
+{
+	const struct ram_config *itr;
+
+	for (itr = ram_init_map; itr->init != NULL; itr++)
+		if (itr->config == config)
+			return itr;
+
+	return NULL;
+}
+
+static const struct ram_config *getRam(void)
+{
+	const struct ram_config *ram = NULL;
+	struct m2config config;
+
+	m2config_get(&config);
+	ram = findRam(config.ram);
+
+	return ram;
+}
+
+void sdram_init(void)
+{
+	const struct ram_config *ram = getRam();
+
+	ram->init();
+
+	/* Set OCP_CONFIG (fix LCD pixel shift during operation) */
+	writel(EMIF_OCP_CONFIG_BYTEENGINE_M2, EMIF_OCP_CONFIG);
+}
+
+const struct dpll_params *get_dpll_ddr_params(void)
+{
+	enable_i2c0_pin_mux();
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE);
+
+	const struct ram_config *ram = getRam();
+
+	return ram->dpll_param;
+}
diff --git a/board/bytesatwork/byteengine_m2/u-boot.lds b/board/bytesatwork/byteengine_m2/u-boot.lds
new file mode 100644
index 0000000000..cb05d50545
--- /dev/null
+++ b/board/bytesatwork/byteengine_m2/u-boot.lds
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		*(.__image_copy_start)
+		*(.vectors)
+		CPUDIR/start.o (.text*)
+		board/bytesatwork/byteengine_m2/built-in.o (.text*)
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+
+	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*)));
+	}
+
+	. = ALIGN(4);
+
+	.__efi_runtime_start : {
+		*(.__efi_runtime_start)
+	}
+
+	.efi_runtime : {
+		*(efi_runtime_text)
+		*(efi_runtime_data)
+	}
+
+	.__efi_runtime_stop : {
+		*(.__efi_runtime_stop)
+	}
+
+	.efi_runtime_rel_start :
+	{
+		*(.__efi_runtime_rel_start)
+	}
+
+	.efi_runtime_rel : {
+		*(.relefi_runtime_text)
+		*(.relefi_runtime_data)
+	}
+
+	.efi_runtime_rel_stop :
+	{
+		*(.__efi_runtime_rel_stop)
+	}
+
+	. = ALIGN(4);
+
+	.image_copy_end :
+	{
+		*(.__image_copy_end)
+	}
+
+	.rel_dyn_start :
+	{
+		*(.__rel_dyn_start)
+	}
+
+	.rel.dyn : {
+		*(.rel*)
+	}
+
+	.rel_dyn_end :
+	{
+		*(.__rel_dyn_end)
+	}
+
+	.hash : { *(.hash*) }
+
+	.end :
+	{
+		*(.__end)
+	}
+
+	_image_binary_end = .;
+
+	/*
+	 * Deprecated: this MMU section is used by pxa at present but
+	 * should not be used by new boards/CPUs.
+	 */
+	. = ALIGN(4096);
+	.mmutable : {
+		*(.mmutable)
+	}
+
+/*
+ * Compiler-generated __bss_start and __bss_end, see arch/arm/lib/bss.c
+ * __bss_base and __bss_limit are for linker only (overlay ordering)
+ */
+
+	.bss_start __rel_dyn_start (OVERLAY) : {
+		KEEP(*(.__bss_start));
+		__bss_base = .;
+	}
+
+	.bss __bss_base (OVERLAY) : {
+		*(.bss*)
+		 . = ALIGN(4);
+		 __bss_limit = .;
+	}
+
+	.bss_end __bss_limit (OVERLAY) : {
+		KEEP(*(.__bss_end));
+	}
+
+	.dynsym _image_binary_end : { *(.dynsym) }
+	.dynbss : { *(.dynbss) }
+	.dynstr : { *(.dynstr*) }
+	.dynamic : { *(.dynamic*) }
+	.gnu.hash : { *(.gnu.hash) }
+	.plt : { *(.plt*) }
+	.interp : { *(.interp*) }
+	.gnu : { *(.gnu*) }
+	.ARM.exidx : { *(.ARM.exidx*) }
+}
diff --git a/configs/byteengine_m2_defconfig b/configs/byteengine_m2_defconfig
new file mode 100644
index 0000000000..634aa0a3c5
--- /dev/null
+++ b/configs/byteengine_m2_defconfig
@@ -0,0 +1,62 @@
+CONFIG_ARM=y
+CONFIG_ARCH_OMAP2PLUS=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_AM33XX=y
+CONFIG_TARGET_BYTEENGINE_M2=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_SPL_FAT_SUPPORT=y
+CONFIG_DEFAULT_DEVICE_TREE="byteengine-m2"
+CONFIG_SPL_SYS_MALLOC_F_LEN=0x1000
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_LOGLEVEL=3
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_SPL=y
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR is not set
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_MTD_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="U-Boot> "
+CONFIG_CMD_SPL=y
+CONFIG_CMD_SPL_NAND_OFS=0x00080000
+CONFIG_CMD_MEMINFO=y
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_FPGA is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_NAND=y
+CONFIG_CMD_PART=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTDIDS_DEFAULT="nand0=nand.0"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=nand.0:128k(NAND.SPL),128k(NAND.SPL.backup1),128k(NAND.SPL.backup2),128k(NAND.SPL.backup3),256k(NAND.u-boot-spl-os),1m(NAND.u-boot),128k(NAND.u-boot-env),128k(NAND.u-boot-env.backup1),8m(NAND.kernel),-(NAND.file-system)"
+CONFIG_OF_CONTROL=y
+CONFIG_ENV_IS_IN_NAND=y
+# CONFIG_BLK is not set
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+# CONFIG_MMC_HW_PARTITIONING is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_NAND=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_SYS_NS16550=y
+CONFIG_OMAP3_SPI=y
+CONFIG_TIMER=y
+CONFIG_OMAP_TIMER=y
+CONFIG_DYNAMIC_CRC_TABLE=y
+CONFIG_SPL_TINY_MEMSET=y
+# CONFIG_EFI_LOADER is not set
diff --git a/configs/byteengine_m2_rev4_defconfig b/configs/byteengine_m2_rev4_defconfig
new file mode 100644
index 0000000000..30faedebf6
--- /dev/null
+++ b/configs/byteengine_m2_rev4_defconfig
@@ -0,0 +1,63 @@
+CONFIG_ARM=y
+CONFIG_ARCH_OMAP2PLUS=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_AM33XX=y
+CONFIG_TARGET_BYTEENGINE_M2_REV4=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+# CONFIG_SPL_NAND_SUPPORT is not set
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_SPL_FAT_SUPPORT=y
+CONFIG_DEFAULT_DEVICE_TREE="byteengine-m2-rev4"
+CONFIG_SPL_SYS_MALLOC_F_LEN=0x1000
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_SPI_BOOT=y
+CONFIG_LOGLEVEL=3
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_VERSION_VARIABLE=y
+CONFIG_SPL=y
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR is not set
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_MTD_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="U-Boot> "
+CONFIG_CMD_SPL=y
+CONFIG_CMD_MEMINFO=y
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_FPGA is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_SF=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_OF_CONTROL=y
+# CONFIG_BLK is not set
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+# CONFIG_MMC_HW_PARTITIONING is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_SYS_NS16550=y
+CONFIG_OMAP3_SPI=y
+CONFIG_TIMER=y
+CONFIG_OMAP_TIMER=y
+CONFIG_DYNAMIC_CRC_TABLE=y
+CONFIG_SPL_TINY_MEMSET=y
+# CONFIG_EFI_LOADER is not set
diff --git a/include/configs/byteengine_m2.h b/include/configs/byteengine_m2.h
new file mode 100644
index 0000000000..6b9f2bc935
--- /dev/null
+++ b/include/configs/byteengine_m2.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright (C) 2015 bytes at work AG
+ *
+ * Based on am335x_evm.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef BYTEENGINE_M2_H
+#define BYTEENGINE_M2_H
+
+#include <configs/ti_am335x_common.h>
+
+#ifndef CONFIG_SPL_BUILD
+# define CONFIG_TIMESTAMP
+#endif
+
+#define CONFIG_SYS_BOOTM_LEN		(16 << 20)
+
+#define MACH_TYPE_AM335XM2		3701
+#define CONFIG_MACH_TYPE		MACH_TYPE_AM335XM2
+
+/* Clock Defines */
+#define V_OSCK				24000000  /* Clock output from T2 */
+#define V_SCLK				(V_OSCK)
+
+/* Custom script for NOR */
+#define CONFIG_SYS_LDSCRIPT		"board/bytesatwork/byteengine_m2/u-boot.lds"
+
+/* Always 128 KiB env size */
+#define CONFIG_ENV_SIZE			(128 << 10)
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+#ifndef CONFIG_SPL_BUILD
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"mlofile=MLO\0" \
+	"ubootfile=u-boot.img\0" \
+	"kernelfile=uImage\0" \
+	"dtbfile=devtree.dtb\0" \
+	"loadaddr=0x82000000\0" \
+	"dtbaddr=0x83000000\0" \
+	"console=ttyO0,115200n8\0" \
+	"mtd_parts=" MTDPARTS_DEFAULT "\0" \
+	"nand_root=/dev/mtdblock8\0" \
+	"nand_root_fs_type=jffs2\0" \
+	"nand_spl_addr=   0x00000000\0" \
+	"nand_spl_size=   0x00080000\0" \
+	"nand_u-boot_addr=0x00080000\0" \
+	"nand_u-boot_size=0x001e0000\0" \
+	"nand_param_addr= 0x00260000\0" \
+	"nand_param_size= 0x00020000\0" \
+	"nand_dtb_addr=   0x00280000\0" \
+	"nand_dtb_size=   0x00080000\0" \
+	"nand_kernel_addr=0x00300000\0" \
+	"nand_kernel_size=0x00500000\0" \
+	"nand_rootfs_addr=0x00800000\0" \
+	"nand_rootfs_size=0x0f800000\0" \
+	"nand_part_addr=  0x00800000\0" \
+	"mmc_root=/dev/mmcblk0p2\0" \
+	"updatepath=/batw-sw\0" \
+	"nand_args=setenv bootargs " \
+		"console=${console} " \
+		"vt.global_cursor_default=0 " \
+		"${mtd_parts} " \
+		"root=${nand_root} " \
+		"rootfstype=${nand_root_fs_type} " \
+		"rootwait " \
+		"consoleblank=0 " \
+		"; " \
+	"\0" \
+	"nand_boot=echo Booting from nand ...; " \
+		"run nand_args; " \
+		"nand read ${loadaddr} ${nand_kernel_addr} ${nand_kernel_size}; " \
+		"nand read ${dtbaddr} ${nand_dtb_addr} ${nand_dtb_size}; " \
+		"bootm ${loadaddr} - ${dtbaddr}; " \
+	"\0" \
+	"nand_update=echo Updating nand from mmc...; " \
+		"if fatsize mmc 0 ${updatepath}; then " \
+			"if fatload mmc 0 ${loadaddr} ${updatepath}/MLO; then " \
+				"echo Found new SPL, flash it.; "\
+				"nand erase ${nand_spl_addr} ${nand_spl_size}; " \
+				"nand write ${loadaddr} ${nand_spl_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload mmc 0 ${loadaddr} ${updatepath}/u-boot.img; then " \
+				"echo Found new U-Boot, flash it.; "\
+				"nand erase ${nand_u-boot_addr} ${nand_u-boot_size}; " \
+				"nand write ${loadaddr} ${nand_u-boot_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload mmc 0 ${loadaddr} ${updatepath}/devtree.dtb; then " \
+				"echo Found new device tree, flash it.; "\
+				"nand erase ${nand_dtb_addr} ${nand_dtb_size}; " \
+				"nand write ${loadaddr} ${nand_dtb_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload mmc 0 ${loadaddr} ${updatepath}/uImage; then " \
+				"echo Found new uImage, flash it.; "\
+				"nand erase ${nand_kernel_addr} ${nand_kernel_size}; " \
+				"nand write ${loadaddr} ${nand_kernel_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload mmc 0 ${loadaddr} ${updatepath}/rootfs.jffs2; then " \
+				"echo Found new rootfs, flash it.; "\
+				"nand erase ${nand_rootfs_addr} ${nand_rootfs_size}; " \
+				"nand write ${loadaddr} ${nand_rootfs_addr} ${filesize}; " \
+			"fi; " \
+			"echo Flashing done. Remove SD card before power cycling.; " \
+		"else " \
+			"echo Update path ${updatepath} not found.; " \
+		"fi; " \
+	"\0" \
+	"mmc_args=setenv bootargs " \
+		"console=${console} " \
+		"vt.global_cursor_default=0 " \
+		"${mtd_parts} " \
+		"root=${mmc_root} " \
+		"rootwait " \
+		"consoleblank=0 " \
+		"; " \
+	"\0" \
+	"mmc_boot=echo Booting from mmc ...; " \
+		"if fatsize mmc 0 ${kernelfile}; then " \
+			"echo Found kernel on MMC; " \
+			"if fatsize mmc 0 ${dtbfile}; then " \
+				"echo Found device tree on MMC; " \
+				"run mmc_args; " \
+				"fatload mmc 0 ${loadaddr} ${kernelfile}; " \
+				"fatload mmc 0 ${dtbaddr} ${dtbfile}; " \
+				"bootm ${loadaddr} - ${dtbaddr}; " \
+			"else " \
+				"echo Device tree not found on MMC; " \
+			"fi; " \
+		"else " \
+			"echo Kernel not found on MMC; " \
+		"fi; " \
+		"run nand_boot; " \
+	"\0"
+#endif
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmc_dev}; " \
+		"run nand_update; " \
+		"run mmc_boot; " \
+	"else " \
+		"run nand_boot; " \
+	"fi; "
+
+#define M2CONFIG_BUILTIN_PCB	M2_PCB_REV_02
+#define M2CONFIG_BUILTIN_RAM	M2_RAM_K4B2G1646EBIH9
+#define M2CONFIG_BUILTIN_FLASH	M2_NAND_2GBIT
+
+/* NS16550 Configuration */
+#define CONFIG_SYS_NS16550_COM1		0x44e09000
+
+/* PMIC support */
+#define CONFIG_POWER_TPS65910
+
+/* SPL */
+#define CONFIG_SPL_POWER_SUPPORT
+
+/* NAND: device related configs */
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_PAGE_COUNT	(CONFIG_SYS_NAND_BLOCK_SIZE / \
+					 CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_SYS_NAND_PAGE_SIZE	2048
+#define CONFIG_SYS_NAND_OOBSIZE		64
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+/* NAND: driver related configs */
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS	NAND_LARGE_BADBLOCK_POS
+#define CONFIG_SYS_NAND_ECCPOS		{1, 2, 3, 4, 5, 6, 7, 8, 9,\
+						10, 11, 12}
+
+#define CONFIG_SYS_NAND_ECCSIZE		512
+#define CONFIG_SYS_NAND_ECCBYTES	3
+#define CONFIG_NAND_OMAP_ECCSCHEME	OMAP_ECC_HAM1_CODE_HW
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	0x00080000
+
+#define CONFIG_ENV_OFFSET		0x260000
+#define CONFIG_SYS_ENV_SECT_SIZE	CONFIG_SYS_NAND_BLOCK_SIZE
+
+#undef CONFIG_SPL_OS_BOOT
+
+/* NAND support */
+#define MTDPARTS_DEFAULT		"mtdparts=omap2-nand.0:128k(SPL)," \
+					"128k(SPL.backup1)," \
+					"128k(SPL.backup2)," \
+					"128k(SPL.backup3),1920k(u-boot)," \
+					"128k(u-boot-env),512k(devtree),5m(kernel),-(rootfs)"
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND
+							   devices */
+
+/* Network. */
+#define CONFIG_PHY_ADDR			1
+
+/*
+ * Disable MMC DM for SPL build and can be re-enabled after adding
+ * DM support in SPL
+ */
+#ifdef CONFIG_SPL_BUILD
+#undef CONFIG_DM_MMC
+#undef CONFIG_TIMER
+#undef CONFIG_DM_USB
+#endif
+
+#endif
diff --git a/include/configs/byteengine_m2_rev4.h b/include/configs/byteengine_m2_rev4.h
new file mode 100644
index 0000000000..9e9fb84749
--- /dev/null
+++ b/include/configs/byteengine_m2_rev4.h
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2015 bytes at work AG
+ *
+ * Based on am335x_evm.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef BYTEENGINE_M2_REV4_H
+#define BYTEENGINE_M2_REV4_H
+
+#include <configs/ti_am335x_common.h>
+
+#ifndef CONFIG_SPL_BUILD
+# define CONFIG_TIMESTAMP
+#endif
+
+#define CONFIG_SYS_BOOTM_LEN		(16 << 20)
+
+#define MACH_TYPE_AM335XM2		3701
+#define CONFIG_MACH_TYPE		MACH_TYPE_AM335XM2
+
+/* Clock Defines */
+#define V_OSCK				24000000  /* Clock output from T2 */
+#define V_SCLK				(V_OSCK)
+
+/* Custom script for NOR */
+#define CONFIG_SYS_LDSCRIPT		"board/bytesatwork/byteengine_m2/u-boot.lds"
+
+/* need it early */
+#define CONFIG_ENV_SIZE			(64 << 10)
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+#ifndef CONFIG_SPL_BUILD
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"mlofile=MLO\0" \
+	"mlofilespi=MLO.byteswap\0" \
+	"ubootfile=u-boot.img\0" \
+	"kernelfile=uImage\0" \
+	"dtbfile=devtree.dtb\0" \
+	"ubootoffset=0x10000\0" \
+	"spiflashsize=0x80000\0" \
+	"loadaddr=0x82000000\0" \
+	"dtbaddr=0x83000000\0" \
+	"fdt_high=0xffffffff\0" \
+	"console=ttyO0,115200n8\0" \
+	"mmc_root=/dev/mmcblk0p2\0" \
+	"emmc_root=/dev/mmcblk1p2\0" \
+	"updatepath=/batw-sw\0" \
+	"mmc_args=setenv bootargs " \
+		"console=${console} " \
+		"vt.global_cursor_default=0 " \
+		"root=${mmc_root} " \
+		"rootwait " \
+		"consoleblank=0 " \
+		"; " \
+	"\0" \
+	"mmc_boot=echo Booting from mmc ...; " \
+		"if fatsize mmc 0 ${kernelfile}; then " \
+			"echo Found kernel on MMC; " \
+			"if fatsize mmc 0 ${dtbfile}; then " \
+				"echo Found device tree on MMC; " \
+				"run mmc_args; " \
+				"fatload mmc 0 ${loadaddr} ${kernelfile}; " \
+				"fatload mmc 0 ${dtbaddr} ${dtbfile}; " \
+				"bootm ${loadaddr} - ${dtbaddr}; " \
+			"else " \
+				"echo Device tree not found on MMC; " \
+			"fi; " \
+		"else " \
+			"echo Kernel not found on MMC; " \
+		"fi; " \
+	"\0" \
+	"emmc_args=setenv bootargs " \
+		"console=${console} " \
+		"vt.global_cursor_default=0 " \
+		"root=${emmc_root} " \
+		"rootwait " \
+		"consoleblank=0 " \
+		"; " \
+	"\0" \
+	"emmc_boot=echo Booting from Emmc ...; " \
+		"run emmc_args; " \
+		"ext2load mmc 1:1 ${loadaddr} ${kernelfile}; " \
+		"ext2load mmc 1:1 ${dtbaddr} ${dtbfile}; " \
+		"bootm ${loadaddr} - ${dtbaddr}; " \
+	"\0" \
+	"update_spiflash=echo Updating SPI Flash ...; " \
+		"sf probe 0; " \
+		"sf erase 0 +${spiflashsize}; " \
+		"mmc rescan; " \
+		"fatload mmc 0 ${loadaddr} ${mlofilespi}; "\
+		"sf write ${loadaddr} 0 ${filesize}; " \
+		"fatload mmc 0 ${loadaddr} ${ubootfile}; " \
+		"sf write ${loadaddr} ${ubootoffset} ${filesize}; " \
+	"\0"
+#endif
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmc_dev}; " \
+		"run mmc_boot; " \
+	"else " \
+		"run emmc_boot; " \
+	"fi; "
+
+#define M2CONFIG_BUILTIN_PCB	M2_PCB_REV_04
+#define M2CONFIG_BUILTIN_RAM	M2_RAM_MT41K512M16HA107
+#define M2CONFIG_BUILTIN_FLASH	M2_EMMC_4GB
+
+/* NS16550 Configuration */
+#define CONFIG_SYS_NS16550_COM1		0x44e09000
+
+/* PMIC support */
+#define CONFIG_POWER_TPS65910
+
+/* SPL */
+#define CONFIG_SPL_POWER_SUPPORT
+
+/* SPI Nor Flash */
+#define CONFIG_SF_DEFAULT_SPEED		24000000
+/*
+ * Default to using SPI for environment for M25PE40.
+ * 0x000000 - 0x010000 : SPL (64KiB)
+ * 0x010000 - 0x060000 : U-Boot (320kiB)
+ * 0x060000 - 0x080000 : U-Boot Environment (128KiB)
+ */
+#if defined(CONFIG_SPI_BOOT)
+/* SPL related */
+#undef CONFIG_SPL_OS_BOOT		/* Not supported by existing map */
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	0x10000
+
+/* M25PE40: 64 KiB env size */
+#define CONFIG_ENV_SIZE			(64 << 10)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+/* #define CONFIG_SYS_REDUNDAND_ENVIRONMENT */
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#define CONFIG_ENV_SECT_SIZE		(64 << 10) /* 64 KB sectors */
+#define CONFIG_ENV_OFFSET		(320 << 10) /* 768 KiB in */
+/* #define CONFIG_ENV_OFFSET_REDUND	(896 << 10)  896 KiB in */
+#define MTDIDS_DEFAULT			"nor0=m25pe40-flash.0"
+#define MTDPARTS_DEFAULT		"mtdparts=m25pe40-flash.0:64k(SPL)," \
+					"320k(u-boot),128k(u-boot-env1)"
+#endif
+
+#undef CONFIG_SPL_OS_BOOT
+
+/* Network. */
+#define CONFIG_PHY_ADDR			1
+
+/*
+ * Disable MMC DM for SPL build and can be re-enabled after adding
+ * DM support in SPL
+ */
+#ifdef CONFIG_SPL_BUILD
+#undef CONFIG_DM_MMC
+#undef CONFIG_TIMER
+#undef CONFIG_DM_USB
+#endif
+
+#endif
-- 
2.11.0

