From 20a17547cddaa13a932b60ac6cfd614690975eff Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Oliver=20St=C3=A4bler?= <oliver.staebler@bytesatwork.ch>
Date: Wed, 4 Sep 2013 18:20:48 +0200
Subject: [PATCH 1/3] M2: Add module M2

---
 BUILD                               |    4 +
 board/bytesatwork/am335x/Makefile   |   49 +++
 board/bytesatwork/am335x/board.c    |  708 +++++++++++++++++++++++++++++++++++
 board/bytesatwork/am335x/board.h    |   57 +++
 board/bytesatwork/am335x/mux.c      |  287 ++++++++++++++
 board/bytesatwork/am335x/pmic.h     |   80 ++++
 board/bytesatwork/am335x/tps65217.h |   95 +++++
 board/bytesatwork/am335x/u-boot.lds |  104 +++++
 boards.cfg                          |    1 +
 include/configs/am335x_m2.h         |  428 +++++++++++++++++++++
 10 files changed, 1813 insertions(+)
 create mode 100644 BUILD
 create mode 100644 board/bytesatwork/am335x/Makefile
 create mode 100644 board/bytesatwork/am335x/board.c
 create mode 100644 board/bytesatwork/am335x/board.h
 create mode 100644 board/bytesatwork/am335x/mux.c
 create mode 100644 board/bytesatwork/am335x/pmic.h
 create mode 100644 board/bytesatwork/am335x/tps65217.h
 create mode 100644 board/bytesatwork/am335x/u-boot.lds
 create mode 100644 include/configs/am335x_m2.h

diff --git a/BUILD b/BUILD
new file mode 100644
index 0000000..6c2e613
--- /dev/null
+++ b/BUILD
@@ -0,0 +1,4 @@
+# Build u-boot for M2
+make ARCH=arm CROSS_COMPILE=arm-poky-linux-gnueabi- distclean
+make ARCH=arm CROSS_COMPILE=arm-poky-linux-gnueabi- am335x_m2_config
+make ARCH=arm CROSS_COMPILE=arm-poky-linux-gnueabi- -j5
diff --git a/board/bytesatwork/am335x/Makefile b/board/bytesatwork/am335x/Makefile
new file mode 100644
index 0000000..4382457
--- /dev/null
+++ b/board/bytesatwork/am335x/Makefile
@@ -0,0 +1,49 @@
+#
+# Makefile
+#
+# Copyright (C) 2013 bytes at work AG
+#
+# Based on board/ti/am335x
+# Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed "as is" WITHOUT ANY WARRANTY of any
+# kind, whether express or implied; without even the implied warranty
+# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_NOR_BOOT),y)
+COBJS	:= mux.o
+endif
+
+COBJS	+= board.o
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/bytesatwork/am335x/board.c b/board/bytesatwork/am335x/board.c
new file mode 100644
index 0000000..63b7b92
--- /dev/null
+++ b/board/bytesatwork/am335x/board.c
@@ -0,0 +1,708 @@
+/*
+ * board.c
+ *
+ * Board functions for TI AM335X based boards
+ *
+ * Copyright (C) 2013 bytes at work AG
+ *
+ * Based on board/ti/am335x
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <spl.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include "board.h"
+#include "pmic.h"
+#include "tps65217.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct wd_timer *wdtimer = (struct wd_timer *)WDT_BASE;
+#if defined(CONFIG_SPL_BUILD) || (CONFIG_NOR_BOOT)
+static struct uart_sys *uart_base = (struct uart_sys *)DEFAULT_UART_BASE;
+#endif
+
+/* MII mode defines */
+#define MII_MODE_ENABLE		0x0
+#define RGMII_MODE_ENABLE	0x3A
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+static struct am335x_baseboard_id __attribute__((section (".data"))) header;
+
+static inline int board_is_bone(void)
+{
+	return !strncmp(header.name, "A335BONE", HDR_NAME_LEN);
+}
+
+static inline int board_is_bone_lt(void)
+{
+	return !strncmp(header.name, "A335BNLT", HDR_NAME_LEN);
+}
+
+static inline int board_is_evm_sk(void)
+{
+	return !strncmp("A335X_SK", header.name, HDR_NAME_LEN);
+}
+
+static inline int board_is_idk(void)
+{
+	return !strncmp(header.config, "SKU#02", 6);
+}
+
+static int __maybe_unused board_is_gp_evm(void)
+{
+	return !strncmp("A33515BB", header.name, 8);
+}
+
+int board_is_evm_15_or_later(void)
+{
+	return (!strncmp("A33515BB", header.name, 8) &&
+		strncmp("1.5", header.version, 3) <= 0);
+}
+
+/* UART Defines */
+#if defined(CONFIG_SPL_BUILD) || defined(CONFIG_NOR_BOOT)
+/**
+ * tps65217_reg_read() - Generic function that can read a TPS65217 register
+ * @src_reg:          Source register address
+ * @src_val:          Address of destination variable
+ */
+
+unsigned char tps65217_reg_read(uchar src_reg, uchar *src_val)
+{
+        if (i2c_read(TPS65217_CHIP_PM, src_reg, 1, src_val, 1))
+                return 1;
+        return 0;
+}
+
+/**
+ *  tps65217_reg_write() - Generic function that can write a TPS65217 PMIC
+ *                         register or bit field regardless of protection
+ *                         level.
+ *
+ *  @prot_level:        Register password protection.
+ *                      use PROT_LEVEL_NONE, PROT_LEVEL_1, or PROT_LEVEL_2
+ *  @dest_reg:          Register address to write.
+ *  @dest_val:          Value to write.
+ *  @mask:              Bit mask (8 bits) to be applied.  Function will only
+ *                      change bits that are set in the bit mask.
+ *
+ *  @return:            0 for success, 1 for failure.
+ */
+int tps65217_reg_write(uchar prot_level, uchar dest_reg,
+        uchar dest_val, uchar mask)
+{
+        uchar read_val;
+        uchar xor_reg;
+
+        /* if we are affecting only a bit field, read dest_reg and apply the mask */
+        if (mask != MASK_ALL_BITS) {
+                if (i2c_read(TPS65217_CHIP_PM, dest_reg, 1, &read_val, 1))
+                        return 1;
+                read_val &= (~mask);
+                read_val |= (dest_val & mask);
+                dest_val = read_val;
+        }
+
+        if (prot_level > 0) {
+                xor_reg = dest_reg ^ PASSWORD_UNLOCK;
+                if (i2c_write(TPS65217_CHIP_PM, PASSWORD, 1, &xor_reg, 1))
+                        return 1;
+        }
+
+        if (i2c_write(TPS65217_CHIP_PM, dest_reg, 1, &dest_val, 1))
+                return 1;
+
+        if (prot_level == PROT_LEVEL_2) {
+                if (i2c_write(TPS65217_CHIP_PM, PASSWORD, 1, &xor_reg, 1))
+                        return 1;
+
+                if (i2c_write(TPS65217_CHIP_PM, dest_reg, 1, &dest_val, 1))
+                        return 1;
+        }
+
+        return 0;
+}
+
+int tps65217_voltage_update(unsigned char dc_cntrl_reg, unsigned char volt_sel)
+{
+        if ((dc_cntrl_reg != DEFDCDC1) && (dc_cntrl_reg != DEFDCDC2)
+                && (dc_cntrl_reg != DEFDCDC3))
+                return 1;
+
+        /* set voltage level */
+        if (tps65217_reg_write(PROT_LEVEL_2, dc_cntrl_reg, volt_sel, MASK_ALL_BITS))
+                return 1;
+
+        /* set GO bit to initiate voltage transition */
+        if (tps65217_reg_write(PROT_LEVEL_2, DEFSLEW, DCDC_GO, DCDC_GO))
+                return 1;
+
+        return 0;
+}
+
+/*
+ * voltage switching for MPU frequency switching.
+ * @module = mpu - 0, core - 1
+ * @vddx_op_vol_sel = vdd voltage to set
+ */
+
+#define MPU     0
+#define CORE    1
+
+int voltage_update(unsigned int module, unsigned char vddx_op_vol_sel)
+{
+        uchar buf[4];
+        unsigned int reg_offset;
+
+        if(module == MPU)
+                reg_offset = PMIC_VDD1_OP_REG;
+        else
+                reg_offset = PMIC_VDD2_OP_REG;
+
+        /* Select VDDx OP   */
+        if (i2c_read(PMIC_CTRL_I2C_ADDR, reg_offset, 1, buf, 1))
+                return 1;
+
+        buf[0] &= ~PMIC_OP_REG_CMD_MASK;
+
+        if (i2c_write(PMIC_CTRL_I2C_ADDR, reg_offset, 1, buf, 1))
+                return 1;
+
+        /* Configure VDDx OP  Voltage */
+        if (i2c_read(PMIC_CTRL_I2C_ADDR, reg_offset, 1, buf, 1))
+                return 1;
+
+        buf[0] &= ~PMIC_OP_REG_SEL_MASK;
+        buf[0] |= vddx_op_vol_sel;
+
+        if (i2c_write(PMIC_CTRL_I2C_ADDR, reg_offset, 1, buf, 1))
+                return 1;
+
+        if (i2c_read(PMIC_CTRL_I2C_ADDR, reg_offset, 1, buf, 1))
+                return 1;
+
+        if ((buf[0] & PMIC_OP_REG_SEL_MASK ) != vddx_op_vol_sel)
+                return 1;
+
+        return 0;
+}
+
+#define UART_RESET		(0x1 << 1)
+#define UART_CLK_RUNNING_MASK	0x1
+#define UART_SMART_IDLE_EN	(0x1 << 0x3)
+
+static void rtc32k_enable(void)
+{
+	struct rtc_regs *rtc = (struct rtc_regs *)AM335X_RTC_BASE;
+
+	/*
+	 * Unlock the RTC's registers.  For more details please see the
+	 * RTC_SS section of the TRM.  In order to unlock we need to
+	 * write these specific values (keys) in this order.
+	 */
+	writel(0x83e70b13, &rtc->kick0r);
+	writel(0x95a4f1e0, &rtc->kick1r);
+
+	/* Enable the RTC 32K OSC by setting bits 3 and 6. */
+	writel((1 << 3) | (1 << 6), &rtc->osc);
+}
+
+static const struct ddr_data ddr2_data = {
+	.datardsratio0 = ((MT47H128M16RT25E_RD_DQS<<30) |
+			  (MT47H128M16RT25E_RD_DQS<<20) |
+			  (MT47H128M16RT25E_RD_DQS<<10) |
+			  (MT47H128M16RT25E_RD_DQS<<0)),
+	.datawdsratio0 = ((MT47H128M16RT25E_WR_DQS<<30) |
+			  (MT47H128M16RT25E_WR_DQS<<20) |
+			  (MT47H128M16RT25E_WR_DQS<<10) |
+			  (MT47H128M16RT25E_WR_DQS<<0)),
+	.datawiratio0 = ((MT47H128M16RT25E_PHY_WRLVL<<30) |
+			 (MT47H128M16RT25E_PHY_WRLVL<<20) |
+			 (MT47H128M16RT25E_PHY_WRLVL<<10) |
+			 (MT47H128M16RT25E_PHY_WRLVL<<0)),
+	.datagiratio0 = ((MT47H128M16RT25E_PHY_GATELVL<<30) |
+			 (MT47H128M16RT25E_PHY_GATELVL<<20) |
+			 (MT47H128M16RT25E_PHY_GATELVL<<10) |
+			 (MT47H128M16RT25E_PHY_GATELVL<<0)),
+	.datafwsratio0 = ((MT47H128M16RT25E_PHY_FIFO_WE<<30) |
+			  (MT47H128M16RT25E_PHY_FIFO_WE<<20) |
+			  (MT47H128M16RT25E_PHY_FIFO_WE<<10) |
+			  (MT47H128M16RT25E_PHY_FIFO_WE<<0)),
+	.datawrsratio0 = ((MT47H128M16RT25E_PHY_WR_DATA<<30) |
+			  (MT47H128M16RT25E_PHY_WR_DATA<<20) |
+			  (MT47H128M16RT25E_PHY_WR_DATA<<10) |
+			  (MT47H128M16RT25E_PHY_WR_DATA<<0)),
+	.datauserank0delay = MT47H128M16RT25E_PHY_RANK0_DELAY,
+	.datadldiff0 = PHY_DLL_LOCK_DIFF,
+};
+
+static const struct cmd_control ddr2_cmd_ctrl_data = {
+	.cmd0csratio = MT47H128M16RT25E_RATIO,
+	.cmd0dldiff = MT47H128M16RT25E_DLL_LOCK_DIFF,
+	.cmd0iclkout = MT47H128M16RT25E_INVERT_CLKOUT,
+
+	.cmd1csratio = MT47H128M16RT25E_RATIO,
+	.cmd1dldiff = MT47H128M16RT25E_DLL_LOCK_DIFF,
+	.cmd1iclkout = MT47H128M16RT25E_INVERT_CLKOUT,
+
+	.cmd2csratio = MT47H128M16RT25E_RATIO,
+	.cmd2dldiff = MT47H128M16RT25E_DLL_LOCK_DIFF,
+	.cmd2iclkout = MT47H128M16RT25E_INVERT_CLKOUT,
+};
+
+static const struct emif_regs ddr2_emif_reg_data = {
+	.sdram_config = MT47H128M16RT25E_EMIF_SDCFG,
+	.ref_ctrl = MT47H128M16RT25E_EMIF_SDREF,
+	.sdram_tim1 = MT47H128M16RT25E_EMIF_TIM1,
+	.sdram_tim2 = MT47H128M16RT25E_EMIF_TIM2,
+	.sdram_tim3 = MT47H128M16RT25E_EMIF_TIM3,
+	.emif_ddr_phy_ctlr_1 = MT47H128M16RT25E_EMIF_READ_LATENCY,
+};
+
+static const struct ddr_data ddr3_data = {
+	.datardsratio0 = MT41J128MJT125_RD_DQS,
+	.datawdsratio0 = MT41J128MJT125_WR_DQS,
+	.datafwsratio0 = MT41J128MJT125_PHY_FIFO_WE,
+	.datawrsratio0 = MT41J128MJT125_PHY_WR_DATA,
+	.datadldiff0 = PHY_DLL_LOCK_DIFF,
+};
+
+static const struct ddr_data ddr3_beagleblack_data = {
+	.datardsratio0 = MT41K256M16HA125E_RD_DQS,
+	.datawdsratio0 = MT41K256M16HA125E_WR_DQS,
+	.datafwsratio0 = MT41K256M16HA125E_PHY_FIFO_WE,
+	.datawrsratio0 = MT41K256M16HA125E_PHY_WR_DATA,
+	.datadldiff0 = PHY_DLL_LOCK_DIFF,
+};
+
+static const struct ddr_data ddr3_evm_data = {
+	.datardsratio0 = MT41J512M8RH125_RD_DQS,
+	.datawdsratio0 = MT41J512M8RH125_WR_DQS,
+	.datafwsratio0 = MT41J512M8RH125_PHY_FIFO_WE,
+	.datawrsratio0 = MT41J512M8RH125_PHY_WR_DATA,
+	.datadldiff0 = PHY_DLL_LOCK_DIFF,
+};
+
+static const struct cmd_control ddr3_cmd_ctrl_data = {
+	.cmd0csratio = MT41J128MJT125_RATIO,
+	.cmd0dldiff = MT41J128MJT125_DLL_LOCK_DIFF,
+	.cmd0iclkout = MT41J128MJT125_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41J128MJT125_RATIO,
+	.cmd1dldiff = MT41J128MJT125_DLL_LOCK_DIFF,
+	.cmd1iclkout = MT41J128MJT125_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41J128MJT125_RATIO,
+	.cmd2dldiff = MT41J128MJT125_DLL_LOCK_DIFF,
+	.cmd2iclkout = MT41J128MJT125_INVERT_CLKOUT,
+};
+
+static const struct cmd_control ddr3_beagleblack_cmd_ctrl_data = {
+	.cmd0csratio = MT41K256M16HA125E_RATIO,
+	.cmd0dldiff = MT41K256M16HA125E_DLL_LOCK_DIFF,
+	.cmd0iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41K256M16HA125E_RATIO,
+	.cmd1dldiff = MT41K256M16HA125E_DLL_LOCK_DIFF,
+	.cmd1iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41K256M16HA125E_RATIO,
+	.cmd2dldiff = MT41K256M16HA125E_DLL_LOCK_DIFF,
+	.cmd2iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+};
+
+static const struct cmd_control ddr3_evm_cmd_ctrl_data = {
+	.cmd0csratio = MT41J512M8RH125_RATIO,
+	.cmd0dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd0iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41J512M8RH125_RATIO,
+	.cmd1dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd1iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41J512M8RH125_RATIO,
+	.cmd2dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd2iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+};
+
+static struct emif_regs ddr3_emif_reg_data = {
+	.sdram_config = MT41J128MJT125_EMIF_SDCFG,
+	.ref_ctrl = MT41J128MJT125_EMIF_SDREF,
+	.sdram_tim1 = MT41J128MJT125_EMIF_TIM1,
+	.sdram_tim2 = MT41J128MJT125_EMIF_TIM2,
+	.sdram_tim3 = MT41J128MJT125_EMIF_TIM3,
+	.zq_config = MT41J128MJT125_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41J128MJT125_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+static struct emif_regs ddr3_beagleblack_emif_reg_data = {
+	.sdram_config = MT41K256M16HA125E_EMIF_SDCFG,
+	.ref_ctrl = MT41K256M16HA125E_EMIF_SDREF,
+	.sdram_tim1 = MT41K256M16HA125E_EMIF_TIM1,
+	.sdram_tim2 = MT41K256M16HA125E_EMIF_TIM2,
+	.sdram_tim3 = MT41K256M16HA125E_EMIF_TIM3,
+	.zq_config = MT41K256M16HA125E_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41K256M16HA125E_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+static struct emif_regs ddr3_evm_emif_reg_data = {
+	.sdram_config = MT41J512M8RH125_EMIF_SDCFG,
+	.ref_ctrl = MT41J512M8RH125_EMIF_SDREF,
+	.sdram_tim1 = MT41J512M8RH125_EMIF_TIM1,
+	.sdram_tim2 = MT41J512M8RH125_EMIF_TIM2,
+	.sdram_tim3 = MT41J512M8RH125_EMIF_TIM3,
+	.zq_config = MT41J512M8RH125_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41J512M8RH125_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+void am33xx_spl_board_init(void)
+{
+	int mpu_vdd, mpu_pll, sil_rev;
+
+	/* Assume PG 1.0 */
+	mpu_pll = MPUPLL_M_720;
+
+	sil_rev = readl(&cdev->deviceid) >> 28;
+	if (sil_rev == 1)
+		/* PG 2.0, efuse may not be set. */
+		mpu_pll = MPUPLL_M_800;
+	else if (sil_rev >= 2) {
+		/* Check what the efuse says our max speed is. */
+		int efuse_arm_mpu_max_freq;
+		efuse_arm_mpu_max_freq = readl(&cdev->efuse_sma);
+		if ((efuse_arm_mpu_max_freq & DEVICE_ID_MASK) ==
+				AM335X_ZCZ_1000)
+			mpu_pll = MPUPLL_M_1000;
+		else if ((efuse_arm_mpu_max_freq & DEVICE_ID_MASK) ==
+				AM335X_ZCZ_800)
+			mpu_pll = MPUPLL_M_800;
+	}
+
+	uchar buf[4];
+
+	/*
+	 * The GP EVM, IDK and EVM SK use a TPS65910 PMIC.  For all
+	 * MPU frequencies we support we use a CORE voltage of
+	 * 1.1375V.  For 1GHz we need to use an MPU voltage of
+	 * 1.3250V and for 720MHz or 800MHz we use 1.2625V.
+	 */
+	if (i2c_probe(PMIC_CTRL_I2C_ADDR))
+		return;
+
+	/* VDD1/2 voltage selection register access by control i/f */
+	if (i2c_read(PMIC_CTRL_I2C_ADDR, PMIC_DEVCTRL_REG, 1, buf, 1))
+		return;
+
+	buf[0] |= PMIC_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C;
+
+	if (i2c_write(PMIC_CTRL_I2C_ADDR, PMIC_DEVCTRL_REG, 1, buf, 1))
+		return;
+
+	/*
+	 * Unless we're running at 1GHz we use thesame VDD for
+	 * all other frequencies we switch to (currently 720MHz,
+	 * 800MHz or 1GHz).
+	 */
+	if (mpu_pll == MPUPLL_M_1000)
+		mpu_vdd = PMIC_OP_REG_SEL_1_3_2_5;
+	else
+		mpu_vdd = PMIC_OP_REG_SEL_1_2_6;
+
+	if (!voltage_update(CORE, PMIC_OP_REG_SEL_1_1_3))
+		core_pll_config(OPP_100);
+	if (!voltage_update(MPU, mpu_vdd))
+		mpu_pll_config(mpu_pll);
+}
+#endif
+
+/*
+ * early system init of muxing and clocks.
+ */
+void s_init(void)
+{
+	__maybe_unused struct am335x_baseboard_id header;
+#ifdef CONFIG_NOR_BOOT
+	asm("stmfd      sp!, {r2 - r4}");
+	asm("movw       r4, #0x8A4");
+	asm("movw       r3, #0x44E1");
+	asm("orr        r4, r4, r3, lsl #16");
+	asm("mov        r2, #9");
+	asm("mov        r3, #8");
+	asm("gpmc_mux:  str     r2, [r4], #4");
+	asm("subs       r3, r3, #1");
+	asm("bne        gpmc_mux");
+	asm("ldmfd      sp!, {r2 - r4}");
+#endif
+
+	/* WDT1 is already running when the bootloader gets control
+	 * Disable it to avoid "random" resets
+	 */
+	writel(0xAAAA, &wdtimer->wdtwspr);
+	while (readl(&wdtimer->wdtwwps) != 0x0)
+		;
+	writel(0x5555, &wdtimer->wdtwspr);
+	while (readl(&wdtimer->wdtwwps) != 0x0)
+		;
+
+#if defined(CONFIG_SPL_BUILD) || defined(CONFIG_NOR_BOOT)
+	/* Setup the PLLs and the clocks for the peripherals */
+	pll_init();
+
+	/* Enable RTC32K clock */
+	rtc32k_enable();
+
+	/* UART softreset */
+	u32 regVal;
+
+#ifdef CONFIG_SERIAL1
+	enable_uart0_pin_mux();
+#endif /* CONFIG_SERIAL1 */
+#ifdef CONFIG_SERIAL2
+	enable_uart1_pin_mux();
+#endif /* CONFIG_SERIAL2 */
+#ifdef CONFIG_SERIAL3
+	enable_uart2_pin_mux();
+#endif /* CONFIG_SERIAL3 */
+#ifdef CONFIG_SERIAL4
+	enable_uart3_pin_mux();
+#endif /* CONFIG_SERIAL4 */
+#ifdef CONFIG_SERIAL5
+	enable_uart4_pin_mux();
+#endif /* CONFIG_SERIAL5 */
+#ifdef CONFIG_SERIAL6
+	enable_uart5_pin_mux();
+#endif /* CONFIG_SERIAL6 */
+
+	regVal = readl(&uart_base->uartsyscfg);
+	regVal |= UART_RESET;
+	writel(regVal, &uart_base->uartsyscfg);
+	while ((readl(&uart_base->uartsyssts) &
+		UART_CLK_RUNNING_MASK) != UART_CLK_RUNNING_MASK)
+		;
+
+	/* Disable smart idle */
+	regVal = readl(&uart_base->uartsyscfg);
+	regVal |= UART_SMART_IDLE_EN;
+	writel(regVal, &uart_base->uartsyscfg);
+
+#if defined(CONFIG_NOR_BOOT)
+	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
+	gd->baudrate = CONFIG_BAUDRATE;
+	serial_init();
+	gd->have_console = 1;
+#else
+	gd = &gdata;
+
+	preloader_console_init();
+#endif
+
+	/* Initalize the board header */
+	enable_i2c0_pin_mux();
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+
+	enable_board_pin_mux();
+
+#ifdef CONFIG_NOR_BOOT
+	am33xx_spl_board_init();
+#endif
+
+	if (!strncmp("A335X_SK", header.name, HDR_NAME_LEN))
+		config_ddr(303, MT41J128MJT125_IOCTRL_VALUE, &ddr3_data,
+			   &ddr3_cmd_ctrl_data, &ddr3_emif_reg_data);
+	else if  (!strncmp("A335BNLT", header.name, 8))
+		config_ddr(400, MT41K256M16HA125E_IOCTRL_VALUE,
+			   &ddr3_beagleblack_data,
+			   &ddr3_beagleblack_cmd_ctrl_data,
+			   &ddr3_beagleblack_emif_reg_data);
+	else if (!strncmp("A33515BB", header.name, 8) &&
+				strncmp("1.5", header.version, 3) <= 0)
+		config_ddr(303, MT41J512M8RH125_IOCTRL_VALUE, &ddr3_evm_data,
+			   &ddr3_evm_cmd_ctrl_data, &ddr3_evm_emif_reg_data);
+	else
+		config_ddr(266, MT47H128M16RT25E_IOCTRL_VALUE, &ddr2_data,
+			   &ddr2_cmd_ctrl_data, &ddr2_emif_reg_data);
+#endif
+}
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+	gd->bd->bi_boot_params = PHYS_DRAM_1 + 0x100;
+
+	gpmc_init();
+
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	char safe_string[HDR_NAME_LEN + 1];
+
+	/* Now set variables based on the header. */
+	strncpy(safe_string, (char *)header.name, sizeof(header.name));
+	safe_string[sizeof(header.name)] = 0;
+	setenv("board_name", safe_string);
+
+	strncpy(safe_string, (char *)header.version, sizeof(header.version));
+	safe_string[sizeof(header.version)] = 0;
+	setenv("board_rev", safe_string);
+#endif
+
+	return 0;
+}
+#endif
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+static void cpsw_control(int enabled)
+{
+	/* VTP can be added here */
+
+	return;
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+	{
+		.slave_reg_ofs	= 0x208,
+		.sliver_reg_ofs	= 0xd80,
+		.phy_id		= 0,
+	},
+	{
+		.slave_reg_ofs	= 0x308,
+		.sliver_reg_ofs	= 0xdc0,
+		.phy_id		= 1,
+	},
+};
+
+static struct cpsw_platform_data cpsw_data = {
+	.mdio_base		= AM335X_CPSW_MDIO_BASE,
+	.cpsw_base		= AM335X_CPSW_BASE,
+	.mdio_div		= 0xff,
+	.channels		= 8,
+	.cpdma_reg_ofs		= 0x800,
+	.slaves			= 1,
+	.slave_data		= cpsw_slaves,
+	.ale_reg_ofs		= 0xd00,
+	.ale_entries		= 1024,
+	.host_port_reg_ofs	= 0x108,
+	.hw_stats_reg_ofs	= 0x900,
+	.mac_control		= (1 << 5),
+	.control		= cpsw_control,
+	.host_port_num		= 0,
+	.version		= CPSW_CTRL_VERSION_2,
+};
+#endif
+
+#if defined(CONFIG_DRIVER_TI_CPSW) || \
+	(defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET))
+int board_eth_init(bd_t *bis)
+{
+	int rv, n = 0;
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+
+	/* try reading mac address from efuse */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+	if (!getenv("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ether_addr(mac_addr))
+			eth_setenv_enetaddr("ethaddr", mac_addr);
+	}
+
+	if (board_is_bone() || board_is_bone_lt() || board_is_idk()) {
+		writel(MII_MODE_ENABLE, &cdev->miisel);
+		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
+				PHY_INTERFACE_MODE_MII;
+	} else {
+		writel(RGMII_MODE_ENABLE, &cdev->miisel);
+		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
+				PHY_INTERFACE_MODE_RGMII;
+	}
+
+	rv = cpsw_register(&cpsw_data);
+	if (rv < 0)
+		printf("Error %d registering CPSW switch\n", rv);
+	else
+		n += rv;
+
+	/*
+	 *
+	 * CPSW RGMII Internal Delay Mode is not supported in all PVT
+	 * operating points.  So we must set the TX clock delay feature
+	 * in the AR8051 PHY.  Since we only support a single ethernet
+	 * device in U-Boot, we only do this for the first instance.
+	 */
+#define AR8051_PHY_DEBUG_ADDR_REG	0x1d
+#define AR8051_PHY_DEBUG_DATA_REG	0x1e
+#define AR8051_DEBUG_RGMII_CLK_DLY_REG	0x5
+#define AR8051_RGMII_TX_CLK_DLY		0x100
+
+	if (board_is_evm_sk() || board_is_gp_evm()) {
+		const char *devname;
+		devname = miiphy_get_current_dev();
+
+		miiphy_write(devname, 0x0, AR8051_PHY_DEBUG_ADDR_REG,
+				AR8051_DEBUG_RGMII_CLK_DLY_REG);
+		miiphy_write(devname, 0x0, AR8051_PHY_DEBUG_DATA_REG,
+				AR8051_RGMII_TX_CLK_DLY);
+	}
+#endif
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USBETH_SUPPORT))
+	if (is_valid_ether_addr(mac_addr))
+		eth_setenv_enetaddr("usbnet_devaddr", mac_addr);
+
+	rv = usb_eth_initialize(bis);
+	if (rv < 0)
+		printf("Error %d registering USB_ETHER\n", rv);
+	else
+		n += rv;
+#endif
+	return n;
+}
+#endif
diff --git a/board/bytesatwork/am335x/board.h b/board/bytesatwork/am335x/board.h
new file mode 100644
index 0000000..3b8533f
--- /dev/null
+++ b/board/bytesatwork/am335x/board.h
@@ -0,0 +1,57 @@
+/*
+ * board.h
+ *
+ * TI AM335x boards information header
+ *
+ * Copyright (C) 2013 bytes at work AG
+ *
+ * Based on board/ti/am335x
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+/*
+ * TI AM335x parts define a system EEPROM that defines certain sub-fields.
+ * We use these fields to in turn see what board we are on, and what
+ * that might require us to set or not set.
+ */
+#define HDR_NO_OF_MAC_ADDR	3
+#define HDR_ETH_ALEN		6
+#define HDR_NAME_LEN		8
+
+struct am335x_baseboard_id {
+	unsigned int  magic;
+	char name[HDR_NAME_LEN];
+	char version[4];
+	char serial[12];
+	char config[32];
+	char mac_addr[HDR_NO_OF_MAC_ADDR][HDR_ETH_ALEN];
+};
+
+/*
+ * We have three pin mux functions that must exist.  We must be able to enable
+ * uart0, for initial output and i2c0 to read the main EEPROM.  We then have a
+ * main pinmux function that can be overridden to enable all other pinmux that
+ * is required on the board.
+ */
+void enable_uart0_pin_mux(void);
+void enable_uart1_pin_mux(void);
+void enable_uart2_pin_mux(void);
+void enable_uart3_pin_mux(void);
+void enable_uart4_pin_mux(void);
+void enable_uart5_pin_mux(void);
+void enable_i2c0_pin_mux(void);
+void enable_board_pin_mux(void);
+#endif
diff --git a/board/bytesatwork/am335x/mux.c b/board/bytesatwork/am335x/mux.c
new file mode 100644
index 0000000..a11418d
--- /dev/null
+++ b/board/bytesatwork/am335x/mux.c
@@ -0,0 +1,287 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2013 bytes at work AG
+ *
+ * Based on board/ti/am335x
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "board.h"
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart1_pin_mux[] = {
+	{OFFSET(uart1_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART1_RXD */
+	{OFFSET(uart1_txd), (MODE(0) | PULLUDEN)},		/* UART1_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart2_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART2_RXD */
+	{OFFSET(spi0_d0), (MODE(1) | PULLUDEN)},		/* UART2_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart3_pin_mux[] = {
+	{OFFSET(spi0_cs1), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(ecap0_in_pwm0_out), (MODE(1) | PULLUDEN)},	/* UART3_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart4_pin_mux[] = {
+	{OFFSET(gpmc_wait0), (MODE(6) | PULLUP_EN | RXACTIVE)},	/* UART4_RXD */
+	{OFFSET(gpmc_wpn), (MODE(6) | PULLUDEN)},		/* UART4_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart5_pin_mux[] = {
+	{OFFSET(lcd_data9), (MODE(4) | PULLUP_EN | RXACTIVE)},	/* UART5_RXD */
+	{OFFSET(lcd_data8), (MODE(4) | PULLUDEN)},		/* UART5_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_no_cd_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_sk_evm[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(gpmc_csn0), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(gpmc_advn_ale), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_CD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_7_pin_mux[] = {
+	{OFFSET(ecap0_in_pwm0_out), (MODE(7) | PULLUDEN)},	/* GPIO0_7 */
+	{-1},
+};
+
+static struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD0 */
+	{OFFSET(gpmc_ad1), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD1 */
+	{OFFSET(gpmc_ad2), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD2 */
+	{OFFSET(gpmc_ad3), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD3 */
+	{OFFSET(gpmc_ad4), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD4 */
+	{OFFSET(gpmc_ad5), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD5 */
+	{OFFSET(gpmc_ad6), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD6 */
+	{OFFSET(gpmc_ad7), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD7 */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NAND WAIT */
+	{OFFSET(gpmc_wpn), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN)},	/* NAND_CS0 */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN)}, /* NAND_ADV_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN)},	/* NAND_OE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN)},	/* NAND_WEN */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN)},	/* NAND_BE_CLE */
+	{-1},
+};
+
+#if defined(CONFIG_NOR) && !defined(CONFIG_NOR_BOOT)
+static struct module_pin_mux bone_norcape_pin_mux[] = {
+	{OFFSET(lcd_data0), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A0 */
+	{OFFSET(lcd_data1), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A1 */
+	{OFFSET(lcd_data2), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A2 */
+	{OFFSET(lcd_data3), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A3 */
+	{OFFSET(lcd_data4), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A4 */
+	{OFFSET(lcd_data5), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A5 */
+	{OFFSET(lcd_data6), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A6 */
+	{OFFSET(lcd_data7), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A7 */
+	{OFFSET(lcd_vsync), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A8 */
+	{OFFSET(lcd_hsync), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A9 */
+	{OFFSET(lcd_pclk), MODE(1)| PULLUDEN | RXACTIVE},       /* NOR_A10 */
+	{OFFSET(lcd_ac_bias_en), MODE(1)| PULLUDEN | RXACTIVE}, /* NOR_A11 */
+	{OFFSET(lcd_data8), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A12 */
+	{OFFSET(lcd_data9), MODE(1) | PULLUDEN | RXACTIVE},     /* NOR_A13 */
+	{OFFSET(lcd_data10), MODE(1) | PULLUDEN | RXACTIVE},    /* NOR_A14 */
+	{OFFSET(lcd_data11), MODE(1) | PULLUDEN | RXACTIVE},    /* NOR_A15 */
+	{OFFSET(lcd_data12), MODE(1) | PULLUDEN | RXACTIVE},    /* NOR_A16 */
+	{OFFSET(lcd_data13), MODE(1) | PULLUDEN | RXACTIVE},    /* NOR_A17 */
+	{OFFSET(lcd_data14), MODE(1) | PULLUDEN | RXACTIVE},    /* NOR_A18 */
+	{OFFSET(lcd_data15), MODE(1) | PULLUDEN | RXACTIVE},    /* NOR_A19 */
+	{OFFSET(gpmc_ad0), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | PULLUDEN | RXACTIVE},      /* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | PULLUDEN | RXACTIVE},     /* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | PULLUDEN | RXACTIVE},     /* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | PULLUDEN | RXACTIVE},     /* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | PULLUDEN | RXACTIVE},     /* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | PULLUDEN | RXACTIVE},     /* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | PULLUDEN | RXACTIVE},     /* NOR_AD15 */
+
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN) | RXACTIVE},   /* NOR_CE */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN) | RXACTIVE}, /* NOR_ADVN_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN | RXACTIVE)},/* NOR_OE */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN | RXACTIVE)},/* NOR_BE0N_CLE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN | RXACTIVE)},    /* NOR_WEN */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUDEN)}, /* NOR WAIT */
+	{-1},
+};
+#endif
+
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+void enable_uart1_pin_mux(void)
+{
+	configure_module_pin_mux(uart1_pin_mux);
+}
+
+void enable_uart2_pin_mux(void)
+{
+	configure_module_pin_mux(uart2_pin_mux);
+}
+
+void enable_uart3_pin_mux(void)
+{
+	configure_module_pin_mux(uart3_pin_mux);
+}
+
+void enable_uart4_pin_mux(void)
+{
+	configure_module_pin_mux(uart4_pin_mux);
+}
+
+void enable_uart5_pin_mux(void)
+{
+	configure_module_pin_mux(uart5_pin_mux);
+}
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+void enable_board_pin_mux(void)
+{
+	configure_module_pin_mux(i2c1_pin_mux);
+	configure_module_pin_mux(gpio0_7_pin_mux);
+	configure_module_pin_mux(rgmii1_pin_mux);
+	configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+}
diff --git a/board/bytesatwork/am335x/pmic.h b/board/bytesatwork/am335x/pmic.h
new file mode 100644
index 0000000..c111b02
--- /dev/null
+++ b/board/bytesatwork/am335x/pmic.h
@@ -0,0 +1,80 @@
+/*
+ * pmic.h
+ *
+ * Copyright (C) 2013 bytes at work AG
+ *
+ * Based on board/ti/am335x
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef PMIC_h
+#define PMIC_H
+
+/*
+ * The PMIC on this board is a TPS65910.
+ */
+
+#define PMIC_SR_I2C_ADDR		0x12
+#define PMIC_CTRL_I2C_ADDR		0x2D
+/* PMIC Register offsets */
+#define PMIC_VDD1_REG			0x21
+#define PMIC_VDD1_OP_REG		0x22
+#define PMIC_VDD2_REG			0x24
+#define PMIC_VDD2_OP_REG		0x25
+#define PMIC_DEVCTRL_REG		0x3f
+
+/* VDD2 & VDD1 control register (VDD2_REG & VDD1_REG) */
+#define PMIC_VGAIN_SEL_MASK		(0x3 << 6)
+#define PMIC_ILMAX_MASK			(0x1 << 5)
+#define PMIC_TSTEP_MASK			(0x7 << 2)
+#define PMIC_ST_MASK			(0x3)
+
+#define PMIC_REG_VGAIN_SEL_X1		(0x0 << 6)
+#define PMIC_REG_VGAIN_SEL_X1_0		(0x1 << 6)
+#define PMIC_REG_VGAIN_SEL_X3		(0x2 << 6)
+#define PMIC_REG_VGAIN_SEL_X4		(0x3 << 6)
+
+#define PMIC_REG_ILMAX_1_0_A		(0x0 << 5)
+#define PMIC_REG_ILMAX_1_5_A		(0x1 << 5)
+
+#define PMIC_REG_TSTEP_			(0x0 << 2)
+#define PMIC_REG_TSTEP_12_5		(0x1 << 2)
+#define PMIC_REG_TSTEP_9_4		(0x2 << 2)
+#define PMIC_REG_TSTEP_7_5		(0x3 << 2)
+#define PMIC_REG_TSTEP_6_25		(0x4 << 2)
+#define PMIC_REG_TSTEP_4_7		(0x5 << 2)
+#define PMIC_REG_TSTEP_3_12		(0x6 << 2)
+#define PMIC_REG_TSTEP_2_5		(0x7 << 2)
+
+#define PMIC_REG_ST_OFF			(0x0)
+#define PMIC_REG_ST_ON_HI_POW		(0x1)
+#define PMIC_REG_ST_OFF_1		(0x2)
+#define PMIC_REG_ST_ON_LOW_POW		(0x3)
+
+
+/* VDD2 & VDD1 voltage selection register. (VDD2_OP_REG & VDD1_OP_REG) */
+#define PMIC_OP_REG_SEL				(0x7F)
+
+#define PMIC_OP_REG_CMD_MASK			(0x1 << 7)
+#define PMIC_OP_REG_CMD_OP			(0x0 << 7)
+#define PMIC_OP_REG_CMD_SR			(0x1 << 7)
+
+#define PMIC_OP_REG_SEL_MASK			(0x7F)
+#define PMIC_OP_REG_SEL_1_1_3			(0x2E)	/* 1.1375 V */
+#define PMIC_OP_REG_SEL_1_2_6			(0x38)	/* 1.2625 V */
+#define PMIC_OP_REG_SEL_1_3_2_5			(0x3D)	/* 1.3250 V */
+
+/* Device control register . (DEVCTRL_REG) */
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_MASK	(0x1 << 4)
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_SEL_SR_I2C	(0x0 << 4)
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C	(0x1 << 4)
+
+#endif
diff --git a/board/bytesatwork/am335x/tps65217.h b/board/bytesatwork/am335x/tps65217.h
new file mode 100644
index 0000000..781db7d
--- /dev/null
+++ b/board/bytesatwork/am335x/tps65217.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2013 bytes at work AG
+ *
+ * Based on board/ti/am335x
+ * (C) Copyright 2011
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __TPS65217_H__
+#define __TPS65217_H__
+
+#include <common.h>
+#include <i2c.h>
+
+/* I2C chip address */
+#define TPS65217_CHIP_PM		0x24
+
+/* Registers */
+#define CHIPID				0x00
+#define POWER_PATH			0x01
+#define INTERRUPT			0x02
+#define CHGCONFIG0			0x03
+#define CHGCONFIG1			0x04
+#define CHGCONFIG2			0x05
+#define CHGCONFIG3			0x06
+#define WLEDCTRL1			0x07
+#define WLEDCTRL2			0x08
+#define MUXCTRL				0x09
+#define STATUS				0x0A
+#define PASSWORD			0x0B
+#define PGOOD				0x0C
+#define DEFPG				0x0D
+#define DEFDCDC1			0x0E
+#define DEFDCDC2			0x0F
+#define DEFDCDC3			0x10
+#define DEFSLEW				0x11
+#define DEFLDO1				0x12
+#define DEFLDO2				0x13
+#define DEFLS1				0x14
+#define DEFLS2				0x15
+#define ENABLE				0x16
+#define DEFUVLO				0x18
+#define SEQ1				0x19
+#define SEQ2				0x1A
+#define SEQ3				0x1B
+#define SEQ4				0x1C
+#define SEQ5				0x1D
+#define SEQ6				0x1E
+
+#define PROT_LEVEL_NONE			0x00
+#define PROT_LEVEL_1			0x01
+#define PROT_LEVEL_2			0x02
+
+#define PASSWORD_LOCK_FOR_WRITE		0x00
+#define PASSWORD_UNLOCK			0x7D
+
+#define DCDC_GO				0x80
+
+#define MASK_ALL_BITS			0xFF
+
+#define USB_INPUT_CUR_LIMIT_MASK	0x03
+#define USB_INPUT_CUR_LIMIT_100MA	0x00
+#define USB_INPUT_CUR_LIMIT_500MA	0x01
+#define USB_INPUT_CUR_LIMIT_1300MA	0x02
+#define USB_INPUT_CUR_LIMIT_1800MA	0x03
+
+#define DCDC_VOLT_SEL_1125MV		0x09
+#define DCDC_VOLT_SEL_1275MV		0x0F
+#define DCDC_VOLT_SEL_1325MV		0x11
+
+#define LDO_MASK			0x1F
+#define LDO_VOLTAGE_OUT_1_8		0x06
+#define LDO_VOLTAGE_OUT_3_3		0x1F
+
+#define PWR_SRC_USB_BITMASK		0x4
+#define PWR_SRC_AC_BITMASK		0x8
+#endif
diff --git a/board/bytesatwork/am335x/u-boot.lds b/board/bytesatwork/am335x/u-boot.lds
new file mode 100644
index 0000000..d840f72
--- /dev/null
+++ b/board/bytesatwork/am335x/u-boot.lds
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2013 bytes at work AG
+ *
+ * Based on board/ti/am335x
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		__image_copy_start = .;
+		CPUDIR/start.o (.text*)
+		board/bytesatwork/am335x/libam335x.o (.text*)
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+
+	. = ALIGN(4);
+	.u_boot_list : {
+	#include <u-boot.lst>
+	}
+
+	. = ALIGN(4);
+
+	__image_copy_end = .;
+
+	.rel.dyn : {
+		__rel_dyn_start = .;
+		*(.rel*)
+		__rel_dyn_end = .;
+	}
+
+	.dynsym : {
+		__dynsym_start = .;
+		*(.dynsym)
+	}
+
+	_end = .;
+
+	/*
+	 * Deprecated: this MMU section is used by pxa at present but
+	 * should not be used by new boards/CPUs.
+	 */
+	. = ALIGN(4096);
+	.mmutable : {
+		*(.mmutable)
+	}
+
+	.bss __rel_dyn_start (OVERLAY) : {
+		__bss_start = .;
+		*(.bss*)
+		 . = ALIGN(4);
+		__bss_end__ = .;
+	}
+
+	/DISCARD/ : { *(.dynstr*) }
+	/DISCARD/ : { *(.dynamic*) }
+	/DISCARD/ : { *(.plt*) }
+	/DISCARD/ : { *(.interp*) }
+	/DISCARD/ : { *(.gnu*) }
+}
+
+#if defined(CONFIG_SPL_TEXT_BASE) && defined(CONFIG_SPL_MAX_SIZE)
+ASSERT(__bss_end__ < (CONFIG_SPL_TEXT_BASE + CONFIG_SPL_MAX_SIZE), "SPL image too big");
+#endif
diff --git a/boards.cfg b/boards.cfg
index f07b7b4..857f8e1 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -230,6 +230,7 @@ versatileqemu                arm         arm926ejs   versatile           armltd
 integratorap_cm946es         arm         arm946es    integrator          armltd         -               integratorap:CM946ES
 integratorcp_cm946es         arm         arm946es    integrator          armltd         -               integratorcp:CM946ES
 ca9x4_ct_vxp                 arm         armv7       vexpress            armltd
+am335x_m2                    arm         armv7       am335x              bytesatwork    am33xx      am335x_m2:SERIAL1,CONS_INDEX=1
 am335x_evm                   arm         armv7       am335x              ti             am33xx      am335x_evm:SERIAL1,CONS_INDEX=1
 am335x_evm_nor               arm         armv7       am335x              ti             am33xx      am335x_evm:SERIAL1,CONS_INDEX=1,NOR
 am335x_evm_norboot           arm         armv7       am335x              ti             am33xx      am335x_evm:SERIAL1,CONS_INDEX=1,NOR,NOR_BOOT
diff --git a/include/configs/am335x_m2.h b/include/configs/am335x_m2.h
new file mode 100644
index 0000000..d905d67
--- /dev/null
+++ b/include/configs/am335x_m2.h
@@ -0,0 +1,428 @@
+/*
+ * am335x_evm.h
+ *
+ * Copyright (C) 2013 bytes at work AG
+ *
+ * Based on am335x_evm.h
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __CONFIG_AM335X_M2_H
+#define __CONFIG_AM335X_M2_H
+
+#define CONFIG_AM33XX
+
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+
+#define CONFIG_DMA_COHERENT
+#define CONFIG_DMA_COHERENT_SIZE	(1 << 20)
+
+#define CONFIG_ENV_SIZE			(128 << 10)	/* 128 KiB */
+#define CONFIG_SYS_MALLOC_LEN		(1024 << 10)
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT		"U-Boot# "
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_SYS_NO_FLASH
+#define MACH_TYPE_AM335XM2		3701
+#define CONFIG_MACH_TYPE		MACH_TYPE_AM335XM2
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Custom script for NOR */
+#define CONFIG_SYS_LDSCRIPT		"board/bytesatwork/am335x/u-boot.lds"
+
+#define CONFIG_SYS_CACHELINE_SIZE       64
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_VERSION_VARIABLE
+
+/* set to negative value for no autoboot */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_ENV_VARS_UBOOT_CONFIG
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"bootfile=uImage\0" \
+	"loadaddr=0x82000000\0" \
+	"console=ttyO0,115200n8\0" \
+	"mmc_dev=0\0" \
+	"mmc_root=/dev/mmcblk0p2 rw\0" \
+	"nand_root=/dev/mtdblock4 rw\0" \
+	"mmc_root_fs_type=ext3 rootwait\0" \
+	"nand_root_fs_type=jffs2 rootwait\0" \
+	"nand_spl_addr=0x0\0" \
+	"nand_spl_size=0x20000\0" \
+	"nand_u-boot_addr=0x80000\0" \
+	"nand_u-boot_size=0x1C0000\0" \
+	"nand_kernel_addr=0x280000\0" \
+	"nand_kernel_size=0x500000\0" \
+	"nand_rootfs_addr=0x780000\0" \
+	"nand_rootfs_size=0x8200000\0" \
+	"mmc_load_uimage=fatload mmc ${mmc_dev} ${loadaddr} ${bootfile}\0" \
+	"bootargs_defaults=setenv bootargs " \
+		"console=${console} \0" \
+	"mmc_args=run bootargs_defaults;" \
+		"setenv bootargs ${bootargs} " \
+		"root=${mmc_root} " \
+		"rootfstype=${mmc_root_fs_type}\0" \
+	"nand_args=run bootargs_defaults;" \
+		"setenv bootargs ${bootargs} " \
+		"root=${nand_root} " \
+		"rootfstype=${nand_root_fs_type}\0" \
+	"mmc_boot=run mmc_args; " \
+		"run mmc_load_uimage; " \
+		"bootm ${kloadaddr}\0" \
+	"nand_boot=echo Booting from nand ...; " \
+		"run nand_args; " \
+		"nand read.i ${loadaddr} ${nand_kernel_addr} ${nand_kernel_size}; " \
+		"bootm ${loadaddr}\0" \
+	"usb_flash=usb start; " \
+		"if fatls usb 0 batw-sw; then " \
+			"if fatload usb 0 ${loadaddr} batw-sw/MLO; then " \
+				"echo Found new SPL, flash it.; "\
+				"nand erase ${nand_spl_addr} ${nand_spl_size}; " \
+				"nand write ${loadaddr} ${nand_spl_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload usb 0 ${loadaddr} batw-sw/u-boot.img; then " \
+				"echo Found new U-Boot, flash it.; "\
+				"nand erase ${nand_u-boot_addr} ${nand_u-boot_size}; " \
+				"nand write ${loadaddr} ${nand_u-boot_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload usb 0 ${loadaddr} batw-sw/uImage; then " \
+				"echo Found new uImage, flash it.; "\
+				"nand erase ${nand_kernel_addr} ${nand_kernel_size}; " \
+				"nand write ${loadaddr} ${nand_kernel_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload usb 0 ${loadaddr} batw-sw/rootfs.jffs2; then " \
+				"echo Found new rootfs, flash it.; "\
+				"nand erase ${nand_rootfs_addr} ${nand_rootfs_size}; " \
+				"nand write ${loadaddr} ${nand_rootfs_addr} ${filesize}; " \
+			"fi; " \
+		"fi;\0"
+#endif
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmc_dev};" \
+		"if fatls mmc 0 batw-sw; then " \
+			"if fatload mmc 0 ${loadaddr} batw-sw/MLO; then " \
+				"echo Found new SPL, flash it.; "\
+				"nand erase ${nand_spl_addr} ${nand_spl_size}; " \
+				"nand write ${loadaddr} ${nand_spl_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload mmc 0 ${loadaddr} batw-sw/u-boot.img; then " \
+				"echo Found new U-Boot, flash it.; "\
+				"nand erase ${nand_u-boot_addr} ${nand_u-boot_size}; " \
+				"nand write ${loadaddr} ${nand_u-boot_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload mmc 0 ${loadaddr} batw-sw/uImage; then " \
+				"echo Found new uImage, flash it.; "\
+				"nand erase ${nand_kernel_addr} ${nand_kernel_size}; " \
+				"nand write ${loadaddr} ${nand_kernel_addr} ${filesize}; " \
+			"fi; " \
+			"if fatload mmc 0 ${loadaddr} batw-sw/rootfs.jffs2; then " \
+				"echo Found new rootfs, flash it.; "\
+				"nand erase ${nand_rootfs_addr} ${nand_rootfs_size}; " \
+				"nand write ${loadaddr} ${nand_rootfs_addr} ${filesize}; " \
+			"fi; " \
+		"else run mmc_boot; " \
+		"fi; " \
+	"else run nand_boot; " \
+	"fi; "\
+
+/* Clock Defines */
+#define V_OSCK				24000000  /* Clock output from T2 */
+#define V_SCLK				(V_OSCK)
+
+#define CONFIG_CMD_ECHO
+
+/* We set the max number of command args high to avoid HUSH bugs. */
+#define CONFIG_SYS_MAXARGS		64
+
+/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE \
+					+ sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+/*
+ * memtest works on 8 MB in DRAM after skipping 32MB from
+ * start addr of ram disk
+ */
+#define CONFIG_SYS_MEMTEST_START	(PHYS_DRAM_1 + (64 * 1024 * 1024))
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START \
+					+ (8 * 1024 * 1024))
+
+#define CONFIG_SYS_LOAD_ADDR		0x81000000 /* Default load address */
+#define CONFIG_SYS_HZ			1000 /* 1ms clock */
+
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_OMAP_HSMMC
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_FAT
+#define CONFIG_FAT_WRITE
+#define CONFIG_CMD_EXT2
+#define CONFIG_MTD_DEVICE
+
+/* USB Composite download gadget - g_dnl */
+#define CONFIG_USB_GADGET
+#define CONFIG_USBDOWNLOAD_GADGET
+
+/* USB TI's IDs */
+#define CONFIG_USBD_HS
+#define CONFIG_G_DNL_VENDOR_NUM 0x0403
+#define CONFIG_G_DNL_PRODUCT_NUM 0xBD00
+#define CONFIG_G_DNL_MANUFACTURER "Texas Instruments"
+
+/* USB Device Firmware Update support */
+#define CONFIG_DFU_FUNCTION
+#define CONFIG_DFU_MMC
+#define CONFIG_DFU_NAND
+#define CONFIG_CMD_DFU
+#define DFU_ALT_INFO_MMC \
+	"boot part 0 1;" \
+	"rootfs part 0 2;" \
+	"MLO fat 0 1;" \
+	"MLO.raw mmc 100 100;" \
+	"u-boot.img.raw mmc 300 3C0;" \
+	"u-boot.img fat 0 1;" \
+	"uEnv.txt fat 0 1"
+#define DFU_ALT_INFO_NAND \
+	"SPL part 0 1;" \
+	"SPL.backup1 part 0 2;" \
+	"SPL.backup2 part 0 3;" \
+	"SPL.backup3 part 0 4;" \
+	"u-boot part 0 5;" \
+	"kernel part 0 7;" \
+	"rootfs part 0 8"
+
+ /* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1		/*  1 bank of DRAM */
+#define PHYS_DRAM_1			0x80000000	/* DRAM Bank #1 */
+#define CONFIG_MAX_RAM_BANK_SIZE	(1024 << 18)	/* 256MB */
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_DRAM_1
+#define CONFIG_SYS_INIT_SP_ADDR         (NON_SECURE_SRAM_END - \
+						GENERATED_GBL_DATA_SIZE)
+ /* Platform/Board specific defs */
+#define CONFIG_SYS_TIMERBASE		0x48040000	/* Use Timer2 */
+#define CONFIG_SYS_PTV			2	/* Divisor: 2^(PTV+1) => 8 */
+#define CONFIG_SYS_HZ			1000
+
+/* NS16550 Configuration */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SERIAL_MULTI
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		(48000000)
+#define CONFIG_SYS_NS16550_COM1		0x44e09000	/* Base EVM has UART0 */
+#define CONFIG_SYS_NS16550_COM2		0x48022000	/* UART1 */
+#define CONFIG_SYS_NS16550_COM3		0x48024000	/* UART2 */
+#define CONFIG_SYS_NS16550_COM4		0x481a6000	/* UART3 */
+#define CONFIG_SYS_NS16550_COM5		0x481a8000	/* UART4 */
+#define CONFIG_SYS_NS16550_COM6		0x481aa000	/* UART5 */
+
+/* I2C Configuration */
+#define CONFIG_I2C
+#define CONFIG_CMD_I2C
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_DRIVER_OMAP24XX_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50	/* Main EEPROM */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	2
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+
+#define CONFIG_OMAP_GPIO
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 110, 300, 600, 1200, 2400, \
+4800, 9600, 14400, 19200, 28800, 38400, 56000, 57600, 115200 }
+
+#define CONFIG_ENV_OVERWRITE		1
+#define CONFIG_SYS_CONSOLE_INFO_QUIET
+
+#define CONFIG_ENV_IS_NOWHERE
+
+/* Defines for SPL */
+#define CONFIG_SPL
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_TEXT_BASE		0x402F0400
+#define CONFIG_SPL_MAX_SIZE		(101 * 1024)
+#define CONFIG_SPL_STACK		CONFIG_SYS_INIT_SP_ADDR
+
+#define CONFIG_SPL_BSS_START_ADDR	0x80000000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000		/* 512 KB */
+
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR	0x300 /* address 0x60000 */
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS	0x200 /* 256 KB */
+#define CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION	1
+#define CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME	"u-boot.img"
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_FAT_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBDISK_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_YMODEM_SUPPORT
+#define CONFIG_SPL_NET_SUPPORT
+#define CONFIG_SPL_NET_VCI_STRING	"AM335x U-Boot SPL"
+#define CONFIG_SPL_ETH_SUPPORT
+#define CONFIG_SPL_MUSB_NEW_SUPPORT
+#define CONFIG_SPL_LDSCRIPT		"$(CPUDIR)/omap-common/u-boot-spl.lds"
+
+#define CONFIG_SPL_BOARD_INIT
+#define CONFIG_SPL_NAND_AM33XX_BCH
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_BASE
+#define CONFIG_SPL_NAND_DRIVERS
+#define CONFIG_SPL_NAND_ECC
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_PAGE_COUNT	(CONFIG_SYS_NAND_BLOCK_SIZE / \
+					 CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_SYS_NAND_PAGE_SIZE	2048
+#define CONFIG_SYS_NAND_OOBSIZE		64
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128*1024)
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS	NAND_LARGE_BADBLOCK_POS
+#define CONFIG_SYS_NAND_ECCPOS		{ 2, 3, 4, 5, 6, 7, 8, 9, \
+					 10, 11, 12, 13, 14, 15, 16, 17, \
+					 18, 19, 20, 21, 22, 23, 24, 25, \
+					 26, 27, 28, 29, 30, 31, 32, 33, \
+					 34, 35, 36, 37, 38, 39, 40, 41, \
+					 42, 43, 44, 45, 46, 47, 48, 49, \
+					 50, 51, 52, 53, 54, 55, 56, 57, }
+
+#define CONFIG_SYS_NAND_ECCSIZE		512
+#define CONFIG_SYS_NAND_ECCBYTES	14
+
+#define CONFIG_SYS_NAND_ECCSTEPS	4
+#define	CONFIG_SYS_NAND_ECCTOTAL	(CONFIG_SYS_NAND_ECCBYTES * \
+						CONFIG_SYS_NAND_ECCSTEPS)
+
+#define	CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_TEXT_BASE
+
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	0x80000
+
+/*
+ * 1MB into the SDRAM to allow for SPL's bss at the beginning of SDRAM
+ * 64 bytes before this address should be set aside for u-boot.img's
+ * header. That is 0x800FFFC0--0x80100000 should not be used for any
+ * other needs.
+ */
+#define CONFIG_SYS_TEXT_BASE		0x80800000
+#define CONFIG_SYS_SPL_MALLOC_START	0x80208000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+
+/* Since SPL did pll and ddr initialization for us,
+ * we don't need to do it twice.
+ */
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+/*
+ * USB configuration
+ */
+#define CONFIG_USB_MUSB_DSPS
+#define CONFIG_ARCH_MISC_INIT
+#define CONFIG_MUSB_GADGET
+#define CONFIG_MUSB_PIO_ONLY
+#define CONFIG_USB_GADGET_DUALSPEED
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+#define CONFIG_MUSB_HOST
+#define CONFIG_AM335X_USB0
+#define CONFIG_AM335X_USB0_MODE	MUSB_HOST
+#define CONFIG_AM335X_USB1
+#define CONFIG_AM335X_USB1_MODE MUSB_HOST
+
+#ifdef CONFIG_MUSB_HOST
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#endif
+
+#ifdef CONFIG_MUSB_GADGET
+#define CONFIG_USB_ETHER
+#define CONFIG_USB_ETH_RNDIS
+#define CONFIG_USBNET_HOST_ADDR	"de:ad:be:af:00:00"
+#endif /* CONFIG_MUSB_GADGET */
+
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_USBETH_SUPPORT)
+/* disable host part of MUSB in SPL */
+#undef CONFIG_MUSB_HOST
+/*
+ * Disable UART SPL support so we fit within the 101KiB limit.
+ */
+#undef CONFIG_SPL_ETH_SUPPORT
+#endif
+
+/* Unsupported features */
+#undef CONFIG_USE_IRQ
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_PING
+#define CONFIG_DRIVER_TI_CPSW
+#define CONFIG_MII
+#define CONFIG_BOOTP_DEFAULT
+#define CONFIG_BOOTP_DNS
+#define CONFIG_BOOTP_DNS2
+#define CONFIG_BOOTP_SEND_HOSTNAME
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_NET_RETRY_COUNT         10
+#define CONFIG_NET_MULTI
+#define CONFIG_PHY_GIGE
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ADDR			0
+#define CONFIG_PHY_SMSC
+
+#define CONFIG_NAND
+/* NAND support */
+#ifdef CONFIG_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_MTDPARTS
+#define MTDIDS_DEFAULT			"nand0=omap2-nand.0"
+#define MTDPARTS_DEFAULT		"mtdparts=omap2-nand.0:128k(SPL)," \
+					"128k(SPL.backup1)," \
+					"128k(SPL.backup2)," \
+					"128k(SPL.backup3),1920k(u-boot)," \
+					"128k(u-boot-env),5m(kernel),-(rootfs)"
+#define CONFIG_NAND_OMAP_GPMC
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+#define CONFIG_SYS_NAND_BASE		(0x08000000)	/* physical address */
+							/* to access nand at */
+							/* CS0 */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND
+							   devices */
+#endif
+
+#endif	/* ! __CONFIG_AM335X_M2_H */
-- 
1.7.10.4

