From c2696dc91a6e6fbd69e8f73f2405b40d11df1453 Mon Sep 17 00:00:00 2001
From: Daniel Ammann <daniel.ammann@bytesatwork.ch>
Date: Tue, 3 Apr 2018 08:39:19 +0200
Subject: [PATCH 27/29] m2config: Add support for storing mac address and uid

The maximum eeprom write size is 64 bytes. Therefore, we need to split
longer writes into 64 byte writes. Fix the m2config_eeprom_write and
m2config_eeprom_read functions along the way.
---
 board/bytesatwork/am335x/m2config/README           |  16 ++-
 board/bytesatwork/am335x/m2config/cmd_m2config.c   |  13 ++-
 board/bytesatwork/am335x/m2config/m2config.h       |   3 +
 .../bytesatwork/am335x/m2config/m2config_eeprom.c  | 113 +++++++++++++++++----
 4 files changed, 123 insertions(+), 22 deletions(-)

diff --git a/board/bytesatwork/am335x/m2config/README b/board/bytesatwork/am335x/m2config/README
index d6477d4fb3..a5f7bff2a3 100644
--- a/board/bytesatwork/am335x/m2config/README
+++ b/board/bytesatwork/am335x/m2config/README
@@ -44,7 +44,7 @@ Bytes  Usage
   2    Magic ext.
   2    length
   4    CRC
- 10    Article number
+  4    Article number
   4    Lot
   1    Lot sequence number
  12    Production date
@@ -52,3 +52,17 @@ Bytes  Usage
   6    Flash user
 
 Magic is 0x6235. CRC is the native u-boot crc32.
+
+
+Tracking data EEPROM format
+
+Byte order is the native byte order of the CPU. The format is:
+
+Bytes  Usage
+  2    Magic (tracking data)
+  2    length
+  4    CRC
+ 18    MAC address
+ 16    UID
+
+Magic is 0x6e4a. CRC is the native u-boot crc32.
diff --git a/board/bytesatwork/am335x/m2config/cmd_m2config.c b/board/bytesatwork/am335x/m2config/cmd_m2config.c
index 6b15cd0539..700e3e94ec 100644
--- a/board/bytesatwork/am335x/m2config/cmd_m2config.c
+++ b/board/bytesatwork/am335x/m2config/cmd_m2config.c
@@ -25,6 +25,12 @@ static void print_config(const struct m2config *config)
 		printf("Flash date:      %s\n", config->flashdate);
 		printf("Flash user:      %s\n", config->flashuser);
 	}
+
+	if (config->track_avail == 1) {
+		printf("\n");
+		printf("MAC address:     %s\n", config->macaddr);
+		printf("UID:             %s\n", config->uid);
+	}
 }
 
 #if defined(CONFIG_M2CONFIG_BUILTIN)
@@ -67,7 +73,7 @@ static enum command_ret_t cmd_write(int argc, char * const argv[])
 {
 	struct m2config config;
 
-	if (argc != 9)
+	if (argc != 11)
 		return CMD_RET_USAGE;
 
 	config.pcb = simple_strtoul(argv[0], NULL, 10);
@@ -81,6 +87,9 @@ static enum command_ret_t cmd_write(int argc, char * const argv[])
 	strlcpy(config.flashdate, argv[7], sizeof(config.flashdate));
 	strlcpy(config.flashuser, argv[8], sizeof(config.flashuser));
 
+	strlcpy(config.macaddr, argv[9], sizeof(config.macaddr));
+	strlcpy(config.uid, argv[10], sizeof(config.uid));
+
 	if (m2config_eeprom_write(&config) != 0) {
 		printf ("could not write to EEPROM\n");
 		return CMD_RET_FAILURE;
@@ -190,7 +199,7 @@ enum command_ret_t do_m2config (cmd_tbl_t * cmdtp, int flag, int argc, char * co
 }
 
 U_BOOT_CMD(
-	m2config, 11, 0, do_m2config,
+	m2config, 13, 0, do_m2config,
 	"perform m2 configuration",
 	"- list known configuration values\n"
 #if defined(CONFIG_M2CONFIG_BUILTIN)
diff --git a/board/bytesatwork/am335x/m2config/m2config.h b/board/bytesatwork/am335x/m2config/m2config.h
index 95916b6233..3f5f0ffa50 100644
--- a/board/bytesatwork/am335x/m2config/m2config.h
+++ b/board/bytesatwork/am335x/m2config/m2config.h
@@ -55,6 +55,9 @@ struct m2config {
 	char			proddate[12];
 	char			flashdate[6];
 	char			flashuser[6];
+	bool			track_avail;
+	char			macaddr[18];
+	char			uid[16];
 };
 
 struct m2config_name_pair {
diff --git a/board/bytesatwork/am335x/m2config/m2config_eeprom.c b/board/bytesatwork/am335x/m2config/m2config_eeprom.c
index bf31f770e2..6f6a182ea7 100644
--- a/board/bytesatwork/am335x/m2config/m2config_eeprom.c
+++ b/board/bytesatwork/am335x/m2config/m2config_eeprom.c
@@ -13,11 +13,12 @@
 #include <i2c.h>
 
 #define EEPROM_ADDRESS	0x50
+#define EEPROM_MAXWRITE	64	/* max. page size for writes */
 #define MAGIC  0x6268
 #define EEPROM_EXT_OFFSET 0x14
 #define MAGIC_EXT 0x6235
-
-typedef uint8_t address_t; //TODO: according to the datasheet, this should be 2 bytes
+#define EEPROM_TRACK_OFFSET 0x3d
+#define MAGIC_TRACK 0x6e4a
 
 struct eeprom_header
 {
@@ -42,6 +43,12 @@ struct eeprom_content_ext
 	char		flashuser[6];
 } __attribute__ ((packed));
 
+struct eeprom_content_track
+{
+	char		macaddr[18];
+	char		uid[16];	/* enable use of characters */
+} __attribute__ ((packed));
+
 struct eeprom_data
 {
 	struct eeprom_header	header;
@@ -56,30 +63,74 @@ struct eeprom_data_ext
 	struct eeprom_content_ext	content;
 } __attribute__ ((packed));
 
+struct eeprom_data_track
+{
+	struct eeprom_header		header;
+	uint32_t			crc;
+	struct eeprom_content_track	content;
+} __attribute__ ((packed));
+
 struct eeprom_write_frame
 {
-	address_t		address;
-	struct eeprom_data	content;
-	struct eeprom_data_ext	content_ext;
+	struct eeprom_data		content;
+	struct eeprom_data_ext		content_ext;
+	struct eeprom_data_track	content_track;
 } __attribute__ ((packed));
 
 struct eeprom_read_frame
 {
-	struct eeprom_data	content;
-	struct eeprom_data_ext	content_ext;
+	struct eeprom_data		content;
+	struct eeprom_data_ext		content_ext;
+	struct eeprom_data_track	content_track;
 } __attribute__ ((packed));
 
-int m2config_eeprom_read(struct m2config *config)
+
+static int i2c_write_rdy(void)
 {
-	address_t address = 0;
-	struct eeprom_read_frame frame;
+	/*
+	 * Check if device is ready for write to eeprom. Write can last up to
+	 * 5 ms. Poll with empty write.
+	 */
+	int i, ret = -5;
+	uint8_t dummy = 0xff;	/* i2c_write doesn't like to write NULL pointers */
+
+	for (i = 0; ret < 0 && i < 10; ++i) {
+		if (i2c_write(EEPROM_ADDRESS, 0, 2, &dummy, 0) != 0) {
+			udelay(500);
+		} else {
+			ret = 0;
+			break;
+		}
+	}
+	if (ret)
+		printf("Error: eeprom busy, giving up.\n");
+
+	return ret;
+}
+
+int i2c_long_write(struct eeprom_write_frame frame, int len)
+{
+	int wlen, off = 0;
+
+	while (len > 0) {
+		if (len >= EEPROM_MAXWRITE)
+			wlen = EEPROM_MAXWRITE;
+		else
+			wlen = len;
+		if (i2c_write_rdy() || i2c_write(EEPROM_ADDRESS, off, 2, (uint8_t*) (&frame) + off, wlen) != 0)
+			return -30;
+		len -= wlen;
+		off += wlen;
+	}
 
-	if (i2c_write(EEPROM_ADDRESS, 0, 1, (uint8_t*) &address, sizeof(address)) != 0)
-		return -2;
+	return 0;
+}
 
-	udelay(5);
+int m2config_eeprom_read(struct m2config *config)
+{
+	struct eeprom_read_frame frame;
 
-	if (i2c_read(EEPROM_ADDRESS, 0, 1, (uint8_t*) &frame, sizeof(frame)) != 0)
+	if (i2c_read(EEPROM_ADDRESS, 0, 2, (uint8_t*) &frame, sizeof(frame)) != 0)
 		return -3;
 
 	if (frame.content.header.magic != MAGIC)
@@ -122,6 +173,27 @@ int m2config_eeprom_read(struct m2config *config)
 
 	config->ext_avail = 1;
 
+	config->track_avail = 0;
+	if (frame.content_track.header.magic != MAGIC_TRACK) {
+		printf("track magic wrong\n");
+		return 0;
+	}
+
+	if (frame.content_track.header.length != sizeof(frame.content_track.content)) {
+		printf("track len wrong\n");
+		return 0;
+	}
+
+	if (frame.content_track.crc != crc32(0, (uint8_t*) &frame.content_track.content, sizeof(frame.content_track.content))) {
+		printf("track crc wrong\n");
+		return 0;
+	}
+
+	strlcpy(config->macaddr, frame.content_track.content.macaddr, sizeof(config->macaddr));
+	strlcpy(config->uid, frame.content_track.content.uid, sizeof(config->uid));
+
+	config->track_avail = 1;
+
 	return 0;
 }
 
@@ -131,7 +203,6 @@ int m2config_eeprom_write(struct m2config *config)
 {
 	struct eeprom_write_frame   frame;
 
-	frame.address = 0;
 	frame.content.header.magic = MAGIC;
 	frame.content.header.length = sizeof(frame.content.content);
 	frame.content.content.pcb = config->pcb;
@@ -142,7 +213,6 @@ int m2config_eeprom_write(struct m2config *config)
 
 	frame.content_ext.header.magic = MAGIC_EXT;
 	frame.content_ext.header.length = sizeof(frame.content_ext.content);
-
 	frame.content_ext.content.artno = config->artno;
 	frame.content_ext.content.lot = config->lot;
 	frame.content_ext.content.lotseq = config->lotseq;
@@ -151,7 +221,13 @@ int m2config_eeprom_write(struct m2config *config)
 	strlcpy(frame.content_ext.content.flashuser, config->flashuser, sizeof(frame.content_ext.content.flashuser));
 	frame.content_ext.crc = crc32(0, (uint8_t*) &frame.content_ext.content, sizeof(frame.content_ext.content));
 
-	if (i2c_write(EEPROM_ADDRESS, 0, 1, (uint8_t*) &frame, sizeof(frame)) != 0)
+	frame.content_track.header.magic = MAGIC_TRACK;
+	frame.content_track.header.length = sizeof(frame.content_track.content);
+	strlcpy(frame.content_track.content.macaddr, config->macaddr, sizeof(frame.content_track.content.macaddr));
+	strlcpy(frame.content_track.content.uid, config->uid, sizeof(frame.content_track.content.uid));
+	frame.content_track.crc = crc32(0, (uint8_t*) &frame.content_track.content, sizeof(frame.content_track.content));
+
+	if (i2c_long_write(frame, sizeof(frame)) != 0)
 		return -7;
 
 	return 0;
@@ -162,9 +238,8 @@ int m2config_eeprom_erase(void)
 	struct eeprom_write_frame   frame;
 
 	memset(&frame, 0xff, sizeof(frame));
-	frame.address = 0;
 
-	if (i2c_write(EEPROM_ADDRESS, 0, 1, (uint8_t*) &frame, sizeof(frame)) != 0)
+	if (i2c_long_write(frame, sizeof(frame)) != 0)
 		return -8;
 
 	return 0;
-- 
2.11.0

