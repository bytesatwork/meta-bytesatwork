From 900bc5008352a28dc2c3f6558f316a26fd7fcd0d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Oliver=20St=C3=A4bler?= <oliver.staebler@bytesatwork.ch>
Date: Fri, 6 Dec 2013 15:49:54 +0100
Subject: [PATCH] bytePANEL: Add support for DataImage LVDS Display

---
 arch/arm/configs/am335x_bytepanel_defconfig  |    2 +
 arch/arm/mach-omap2/board-am335x-bytepanel.c |   71 +++++++++++++-------------
 drivers/video/backlight/Kconfig              |   14 +++++
 3 files changed, 51 insertions(+), 36 deletions(-)

diff --git a/arch/arm/configs/am335x_bytepanel_defconfig b/arch/arm/configs/am335x_bytepanel_defconfig
index fdc293b..263f572 100644
--- a/arch/arm/configs/am335x_bytepanel_defconfig
+++ b/arch/arm/configs/am335x_bytepanel_defconfig
@@ -1801,6 +1801,8 @@ CONFIG_LCD_CLASS_DEVICE=y
 # CONFIG_LCD_S6E63M0 is not set
 # CONFIG_LCD_LD9040 is not set
 # CONFIG_LCD_AMS369FG06 is not set
+CONFIG_LCD_ET070080DH6=y
+# CONFIG_LCD_DATAIMAGE is not set
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 # CONFIG_BACKLIGHT_GENERIC is not set
 CONFIG_BACKLIGHT_PWM=y
diff --git a/arch/arm/mach-omap2/board-am335x-bytepanel.c b/arch/arm/mach-omap2/board-am335x-bytepanel.c
index 3a051cf..e6a00ac 100644
--- a/arch/arm/mach-omap2/board-am335x-bytepanel.c
+++ b/arch/arm/mach-omap2/board-am335x-bytepanel.c
@@ -98,11 +98,19 @@ static struct lcd_ctrl_config lcd_cfg = {
 	.raster_order		= 0,
 };
 
-static struct da8xx_lcdc_platform_data EMERGING_pdata = {
+#if defined(CONFIG_LCD_ET070080DH6)
+static struct da8xx_lcdc_platform_data lcdc_pdata = {
 	.manu_name		= "Emerging",
 	.controller_data	= &lcd_cfg,
 	.type			= "EMERGING",
 };
+#elif defined(CONFIG_LCD_DATAIMAGE)
+static struct da8xx_lcdc_platform_data lcdc_pdata = {
+	.manu_name		= "DataImage",
+	.controller_data	= &lcd_cfg,
+	.type			= "DATA_IMAGE",
+};
+#endif
 
 /* LCD backlight platform Data */
 #define AM335X_BACKLIGHT_MAX_BRIGHTNESS		100
@@ -252,6 +260,9 @@ static struct pinmux_config lcdc_pin_mux[] = {
 	{"lcd_hsync.lcd_hsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
 	{"lcd_pclk.lcd_pclk",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
 	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a4.gpio1_20",		OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a9.gpio1_25",		OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a10.gpio1_26",		OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
 	{NULL, 0},
 };
 
@@ -388,7 +399,11 @@ static int __init backlight_init(void)
 	gpio_direction_output(LCD_BACKLIGHT_ENABLE, 1);
 	gpio_export(LCD_BACKLIGHT_ENABLE,0);
 
+#if defined( CONFIG_LCD_ET070080DH6)
 	pwm_pdata.chan_attrib[0].inverse_pol = true;
+#elif defined(CONFIG_LCD_DATAIMAGE)
+	pwm_pdata.chan_attrib[0].inverse_pol = false;
+#endif
 	am33xx_register_ecap(0, &pwm_pdata);
 	platform_device_register(&am335x_backlight);
 	return 0;
@@ -396,13 +411,11 @@ static int __init backlight_init(void)
 late_initcall(backlight_init);
 
 #define LCD_PANEL_PWR GPIO_TO_PIN(1,20)
-#define LCD_PANEL_PWM GPIO_TO_PIN(0,7)
 #define LCD_DATA_ENABLE GPIO_TO_PIN(1,25)
 #define LCD_LVDS_NSHUTDOWN GPIO_TO_PIN(1,26)
 
 static void lcdc_init(void)
 {
-	struct da8xx_lcdc_platform_data *lcdc_pdata;
 	int r;
 	setup_pin_mux(lcdc_pin_mux);
 
@@ -411,60 +424,46 @@ static void lcdc_init(void)
 				"register LCDC\n");
 		return;
 	}
-	lcdc_pdata = &EMERGING_pdata;
 
-	if (am33xx_register_lcdc(lcdc_pdata))
+	if (am33xx_register_lcdc(&lcdc_pdata))
 		pr_info("Failed to register LCDC device\n");
 
-	omap_mux_init_gpio(LCD_PANEL_PWR, OMAP_PIN_OUTPUT);
-	omap_mux_init_gpio(LCD_PANEL_PWM, OMAP_PIN_OUTPUT);
-	omap_mux_init_gpio(LCD_DATA_ENABLE, OMAP_PIN_OUTPUT);
-	omap_mux_init_gpio(LCD_LVDS_NSHUTDOWN, OMAP_PIN_OUTPUT);
-	/*
-	 * Enable LCD
-	 */
 	r = gpio_request(LCD_DATA_ENABLE, "lcd_ena");
 	if (r) {
 		printk(KERN_ERR "failed to get lcd_ena\n");
 		return;
 	}
-	gpio_direction_output(LCD_DATA_ENABLE, 1);
-	gpio_set_value(LCD_DATA_ENABLE,0);
-	gpio_export(LCD_DATA_ENABLE,0);
 
-	/*
-	 * Disable LVDS
-	 */
 	r = gpio_request(LCD_LVDS_NSHUTDOWN, "lcd_lvds");
 	if (r) {
 		printk(KERN_ERR "failed to get lcd_lvds\n");
 		return;
 	}
-	gpio_direction_output(LCD_LVDS_NSHUTDOWN, 1);
-	gpio_set_value(LCD_LVDS_NSHUTDOWN,0);
-	gpio_export(LCD_LVDS_NSHUTDOWN,0);
-	/*
-	 * Enable LCD Panel PWR
-	 */
 	r = gpio_request(LCD_PANEL_PWR, "lcd_pwr");
 	if (r) {
 		printk(KERN_ERR "failed to get lcd_pwr\n");
 		return;
 	}
+
+	/*Enable LCD */
+	gpio_direction_output(LCD_DATA_ENABLE, 0);
+	gpio_export(LCD_DATA_ENABLE,0);
+
+#if defined(CONFIG_LCD_ET070080DH6)
+	/* Disable LVDS */
+	gpio_direction_output(LCD_LVDS_NSHUTDOWN, 0);
+	gpio_export(LCD_LVDS_NSHUTDOWN,0);
+	/* Enable LCD Panel PWR */
 	gpio_direction_output(LCD_PANEL_PWR, 1);
-	gpio_set_value(LCD_PANEL_PWR,1);
 	gpio_export(LCD_PANEL_PWR,0);
-	/*
-	 * Enable LCD Panel PWM
-	 */
-	r = gpio_request(LCD_PANEL_PWM, "lcd_pwm");
-	if (r) {
-		printk(KERN_ERR "failed to get lcd_pwm\n");
-		return;
-	}
-	gpio_direction_output(LCD_PANEL_PWM, 0);
-	gpio_set_value(LCD_PANEL_PWM,0);
-	gpio_export(LCD_PANEL_PWM,0);
+#elif defined(CONFIG_LCD_DATAIMAGE)
+	/* Enable LVDS */
+	gpio_direction_output(LCD_LVDS_NSHUTDOWN, 1);
+	gpio_export(LCD_LVDS_NSHUTDOWN,0);
+	/* Disable LCD Panel PWR */
+	gpio_direction_output(LCD_PANEL_PWR, 0);
+	gpio_export(LCD_PANEL_PWR,0);
+#endif
 
 	printk(KERN_INFO "Display initialized successfully\n");
 
diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index df9dac7..ccbb529 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -125,6 +125,20 @@ config LCD_AMS369FG06
 	  If you have an AMS369FG06 AMOLED Panel, say Y to enable its
 	  LCD control driver.
 
+config LCD_ET070080DH6
+	bool "Emerging ET070080DH6"
+	default y
+	help
+	  If you have an Emerging ET070080DH6 LCD Panel, say Y to enable its
+	  driver.
+
+config LCD_DATAIMAGE
+	bool "Data Image 10.4\""
+	default n
+	help
+	  If you have an Data Image LCD Panel, say Y to enable its driver.
+
+
 endif # LCD_CLASS_DEVICE
 
 #
-- 
1.7.10.4

