From d4333b7295fca3b91211ae91ffc31a002a08a39f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Urs=20F=C3=A4ssler?= <urs@bytesatwork.ch>
Date: Thu, 17 Oct 2013 17:06:22 +0200
Subject: [PATCH] bytePANEL: cleanup board file

removed hardware profiles (BeagleBoard and EVK) and related functionality
removed unused functions and structures
---
 arch/arm/mach-omap2/board-am335x-bytepanel.c | 2206 +++-----------------------
 1 file changed, 226 insertions(+), 1980 deletions(-)

diff --git a/arch/arm/mach-omap2/board-am335x-bytepanel.c b/arch/arm/mach-omap2/board-am335x-bytepanel.c
index e919081..0e921a1 100644
--- a/arch/arm/mach-omap2/board-am335x-bytepanel.c
+++ b/arch/arm/mach-omap2/board-am335x-bytepanel.c
@@ -22,9 +22,6 @@
 #include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
 #include <linux/spi/ads7846.h>
-#include <linux/gpio_keys.h>
-#include <linux/input.h>
-#include <linux/input/matrix_keypad.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
@@ -32,10 +29,8 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/export.h>
-#include <linux/wl12xx.h>
 #include <linux/ethtool.h>
 #include <linux/mfd/tps65910.h>
-#include <linux/mfd/tps65217.h>
 #include <linux/pwm_backlight.h>
 #include <linux/input/ti_tsc.h>
 #include <linux/platform_data/ti_adc.h>
@@ -50,7 +45,6 @@
 #include <video/da8xx-fb.h>
 
 #include <mach/hardware.h>
-#include <mach/board-am335xevm.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -67,30 +61,20 @@
 #include <plat/mmc.h>
 #include <plat/emif.h>
 #include <plat/nand.h>
+#include <linux/lis3lv02d.h>
 
 #include "board-flash.h"
 #include "cpuidle33xx.h"
 #include "mux.h"
 #include "devices.h"
 #include "hsmmc.h"
+#include "common.h"
 
 /* Convert GPIO signal to GPIO pin number */
 #define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
 
 #define FT5X06_IRQ	GPIO_TO_PIN(1,24)
 
-/* BBB PHY IDs */
-#define BBB_PHY_ID		0x7c0f1
-#define BBB_PHY_MASK		0xfffffffe
-
-/* AM335X EVM Phy ID and Debug Registers */
-#define AM335X_EVM_PHY_ID		0x4dd074
-#define AM335X_EVM_PHY_MASK		0xfffffffe
-#define AR8051_PHY_DEBUG_ADDR_REG	0x1d
-#define AR8051_PHY_DEBUG_DATA_REG	0x1e
-#define AR8051_DEBUG_RGMII_CLK_DLY_REG	0x5
-#define AR8051_RGMII_TX_CLK_DLY		BIT(8)
-
 static const struct display_panel disp_panel = {
 	WVGA,
 	32,
@@ -98,29 +82,6 @@ static const struct display_panel disp_panel = {
 	COLOR_ACTIVE,
 };
 
-/* LCD backlight platform Data */
-#define AM335X_BACKLIGHT_MAX_BRIGHTNESS        100
-#define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    100
-#define AM335X_PWM_PERIOD_NANO_SECONDS        (5000 * 10)
-
-static struct platform_pwm_backlight_data am335x_backlight_data0 = {
-	.pwm_id         = "ecap.0",
-	.ch             = -1,
-	.lth_brightness	= 21,
-	.max_brightness = AM335X_BACKLIGHT_MAX_BRIGHTNESS,
-	.dft_brightness = AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS,
-	.pwm_period_ns  = AM335X_PWM_PERIOD_NANO_SECONDS,
-};
-
-static struct platform_pwm_backlight_data am335x_backlight_data2 = {
-	.pwm_id         = "ecap.2",
-	.ch             = -1,
-	.lth_brightness	= 21,
-	.max_brightness = AM335X_BACKLIGHT_MAX_BRIGHTNESS,
-	.dft_brightness = AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS,
-	.pwm_period_ns  = AM335X_PWM_PERIOD_NANO_SECONDS,
-};
-
 static struct lcd_ctrl_config lcd_cfg = {
 	&disp_panel,
 	.ac_bias		= 255,
@@ -138,87 +99,12 @@ static struct lcd_ctrl_config lcd_cfg = {
 	.raster_order		= 0,
 };
 
-struct da8xx_lcdc_platform_data EMERGING_pdata = {
+static struct da8xx_lcdc_platform_data EMERGING_pdata = {
 	.manu_name		= "Emerging",
 	.controller_data	= &lcd_cfg,
 	.type			= "EMERGING",
 };
 
-struct da8xx_lcdc_platform_data TFC_S9700RTWV35TR_01B_pdata = {
-	.manu_name		= "ThreeFive",
-	.controller_data	= &lcd_cfg,
-	.type			= "TFC_S9700RTWV35TR_01B",
-};
-
-struct da8xx_lcdc_platform_data  NHD_480272MF_ATXI_pdata = {
-	.manu_name              = "NHD",
-	.controller_data        = &lcd_cfg,
-	.type                   = "NHD-4.3-ATXI#-T-1",
-};
-
-#include "common.h"
-
-#include <linux/lis3lv02d.h>
-
-/* TSc controller */
-static struct tsc_data am335x_touchscreen_data  = {
-	.wires  = 4,
-	.x_plate_resistance = 200,
-	.steps_to_configure = 5,
-};
-
-static struct adc_data am335x_adc_data = {
-	.adc_channels = 4,
-};
-
-static struct mfd_tscadc_board tscadc = {
-	.tsc_init = &am335x_touchscreen_data,
-	.adc_init = &am335x_adc_data,
-};
-
-static u8 am335x_iis_serializer_direction1[] = {
-	INACTIVE_MODE,	INACTIVE_MODE,	TX_MODE,	RX_MODE,
-	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
-	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
-	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
-};
-
-static struct snd_platform_data am335x_evm_snd_data1 = {
-	.tx_dma_offset	= 0x46400000,	/* McASP1 */
-	.rx_dma_offset	= 0x46400000,
-	.op_mode	= DAVINCI_MCASP_IIS_MODE,
-	.num_serializer	= ARRAY_SIZE(am335x_iis_serializer_direction1),
-	.tdm_slots	= 2,
-	.serial_dir	= am335x_iis_serializer_direction1,
-	.asp_chan_q	= EVENTQ_2,
-	.version	= MCASP_VERSION_3,
-	.txnumevt	= 32,
-	.rxnumevt	= 32,
-	.get_context_loss_count	=
-			omap_pm_get_dev_context_loss_count,
-};
-
-static u8 am335x_evm_sk_iis_serializer_direction1[] = {
-	INACTIVE_MODE,	INACTIVE_MODE,	TX_MODE,	INACTIVE_MODE,
-	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
-	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
-	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
-};
-
-static struct snd_platform_data am335x_evm_sk_snd_data1 = {
-	.tx_dma_offset	= 0x46400000,	/* McASP1 */
-	/*.rx_dma_offset	= 0x46400000,*/
-	.op_mode	= DAVINCI_MCASP_IIS_MODE,
-	.num_serializer	= ARRAY_SIZE(am335x_evm_sk_iis_serializer_direction1),
-	.tdm_slots	= 2,
-	.serial_dir	= am335x_evm_sk_iis_serializer_direction1,
-	.asp_chan_q	= EVENTQ_2,
-	.version	= MCASP_VERSION_3,
-	.txnumevt	= 32,
-	.get_context_loss_count	=
-			omap_pm_get_dev_context_loss_count,
-};
-
 static struct omap2_hsmmc_info am335x_mmc[] __initdata = {
 	{
 		.mmc            = 1,
@@ -231,7 +117,7 @@ static struct omap2_hsmmc_info am335x_mmc[] __initdata = {
 		.mmc            = 0,	/* will be set at runtime */
 	},
 	{
-		.mmc            = 0,	/* will be set at runtime */
+		.mmc    	= 0,	/* will be set at runtime */
 	},
 	{}      /* Terminator */
 };
@@ -271,129 +157,10 @@ struct pinmux_config {
 	int val; /* Options for the mux register value */
 };
 
-struct evm_dev_cfg {
-	void (*device_init)(int evm_id, int profile);
-
-/*
-* If the device is required on both baseboard & daughter board (ex i2c),
-* specify DEV_ON_BASEBOARD
-*/
-#define DEV_ON_BASEBOARD	0
-#define DEV_ON_DGHTR_BRD	1
-	u32 device_on;
-
-	u32 profile;	/* Profiles (0-7) in which the module is present */
-};
-
-/* AM335X - CPLD Register Offsets */
-#define	CPLD_DEVICE_HDR	0x00 /* CPLD Header */
-#define	CPLD_DEVICE_ID	0x04 /* CPLD identification */
-#define	CPLD_DEVICE_REV	0x0C /* Revision of the CPLD code */
-#define	CPLD_CFG_REG	0x10 /* Configuration Register */
-
-static struct i2c_client *cpld_client;
-static u32 am335x_evm_id;
 static struct omap_board_config_kernel am335x_evm_config[] __initdata = {
 };
 
 /*
-* EVM Config held in On-Board eeprom device.
-*
-* Header Format
-*
-*  Name			Size	Contents
-*			(Bytes)
-*-------------------------------------------------------------
-*  Header		4	0xAA, 0x55, 0x33, 0xEE
-*
-*  Board Name		8	Name for board in ASCII.
-*				Example "A33515BB" = "AM335x 15x15 Base Board"
-*
-*  Version		4	Hardware version code for board	in ASCII.
-*				"1.0A" = rev.01.0A
-*
-*  Serial Number	12	Serial number of the board. This is a 12
-*				character string which is WWYY4P16nnnn, where
-*				WW = 2 digit week of the year of production
-*				YY = 2 digit year of production
-*				nnnn = incrementing board number
-*
-*  Configuration option	32	Codes(TBD) to show the configuration
-*				setup on this board.
-*
-*  Available		32720	Available space for other non-volatile data.
-*/
-struct am335x_evm_eeprom_config {
-	u32	header;
-	u8	name[8];
-	char	version[4];
-	u8	serial[12];
-	u8	opt[32];
-};
-
-/*
-* EVM Config held in daughter board eeprom device.
-*
-* Header Format
-*
-*  Name			Size		Contents
-*			(Bytes)
-*-------------------------------------------------------------
-*  Header		4	0xAA, 0x55, 0x33, 0xEE
-*
-*  Board Name		8	Name for board in ASCII.
-*				example "A335GPBD" = "AM335x
-*				General Purpose Daughterboard"
-*
-*  Version		4	Hardware version code for board in
-*				in ASCII. "1.0A" = rev.01.0A
-*  Serial Number	12	Serial number of the board. This is a 12
-*				character string which is: WWYY4P13nnnn, where
-*				WW = 2 digit week of the year of production
-*				YY = 2 digit year of production
-*				nnnn = incrementing board number
-*  Configuration Option	32	Codes to show the configuration
-*				setup on this board.
-*  CPLD Version	8		CPLD code version for board in ASCII
-*				"CPLD1.0A" = rev. 01.0A of the CPLD
-*  Available	32700		Available space for other non-volatile
-*				codes/data
-*/
-
-struct am335x_eeprom_config1 {
-	u32	header;
-	u8	name[8];
-	char	version[4];
-	u8	serial[12];
-	u8	opt[32];
-	u8	cpld_ver[8];
-};
-
-static struct am335x_evm_eeprom_config config;
-static struct am335x_eeprom_config1 config1;
-static bool daughter_brd_detected;
-
-#define EEPROM_MAC_ADDRESS_OFFSET	60 /* 4+8+4+12+32 */
-#define EEPROM_NO_OF_MAC_ADDR		3
-static char am335x_mac_addr[EEPROM_NO_OF_MAC_ADDR][ETH_ALEN];
-
-#define AM335X_EEPROM_HEADER		0xEE3355AA
-
-static int am33xx_evmid = -EINVAL;
-
-/*
-* am335x_evm_set_id - set up board evmid
-* @evmid - evm id which needs to be configured
-*
-* This function is called to configure board evm id.
-*/
-void am335x_evm_set_id(unsigned int evmid)
-{
-	am33xx_evmid = evmid;
-	return;
-}
-
-/*
 * am335x_evm_get_id - returns Board Type (EVM/BB/EVM-SK ...)
 *
 * Note:
@@ -401,33 +168,10 @@ void am335x_evm_set_id(unsigned int evmid)
 */
 int am335x_evm_get_id(void)
 {
-	return am33xx_evmid;
+	return -EINVAL;
 }
 EXPORT_SYMBOL(am335x_evm_get_id);
 
-/* current profile if exists else PROFILE_0 on error */
-static u32 am335x_get_profile_selection(void)
-{
-	int val = 0;
-
-	if (!cpld_client)
-		/* error checking is not done in func's calling this routine.
-		so return profile 0 on error */
-		return 0;
-
-	val = i2c_smbus_read_word_data(cpld_client, CPLD_CFG_REG);
-	if (val < 0)
-		return 0;	/* default to Profile 0 on Error */
-	else
-		return val & 0x7;
-}
-
-static struct pinmux_config haptics_pin_mux[] = {
-	{"gpmc_ad9.ehrpwm2B",		OMAP_MUX_MODE4 |
-		AM33XX_PIN_OUTPUT},
-	{NULL, 0},
-};
-
 /* Module pin mux for LCDC */
 static struct pinmux_config lcdc_pin_mux[] = {
 	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
@@ -510,57 +254,6 @@ static struct pinmux_config spi0_pin_mux[] = {
 	{NULL, 0},
 };
 
-/* Module pin mux for SPI flash */
-static struct pinmux_config spi1_pin_mux[] = {
-	{"mcasp0_aclkx.spi1_sclk", OMAP_MUX_MODE3 | AM33XX_PULL_ENBL
-		| AM33XX_INPUT_EN},
-	{"mcasp0_fsx.spi1_d0", OMAP_MUX_MODE3 | AM33XX_PULL_ENBL
-		| AM33XX_PULL_UP | AM33XX_INPUT_EN},
-	{"mcasp0_axr0.spi1_d1", OMAP_MUX_MODE3 | AM33XX_PULL_ENBL
-		| AM33XX_INPUT_EN},
-	{"mcasp0_ahclkr.spi1_cs0", OMAP_MUX_MODE3 | AM33XX_PULL_ENBL
-		| AM33XX_PULL_UP | AM33XX_INPUT_EN},
-	{NULL, 0},
-};
-
-/* Module pin mux for rgmii1 */
-static struct pinmux_config rgmii1_pin_mux[] = {
-	{"mii1_txen.rgmii1_tctl", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"mii1_rxdv.rgmii1_rctl", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_txd3.rgmii1_td3", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"mii1_txd2.rgmii1_td2", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"mii1_txd1.rgmii1_td1", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"mii1_txd0.rgmii1_td0", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"mii1_txclk.rgmii1_tclk", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"mii1_rxclk.rgmii1_rclk", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_rxd3.rgmii1_rd3", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_rxd2.rgmii1_rd2", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_rxd1.rgmii1_rd1", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_rxd0.rgmii1_rd0", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
-	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
-	{NULL, 0},
-};
-
-/* Module pin mux for rgmii2 */
-static struct pinmux_config rgmii2_pin_mux[] = {
-	{"gpmc_a0.rgmii2_tctl", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"gpmc_a1.rgmii2_rctl", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"gpmc_a2.rgmii2_td3", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"gpmc_a3.rgmii2_td2", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"gpmc_a4.rgmii2_td1", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"gpmc_a5.rgmii2_td0", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"gpmc_a6.rgmii2_tclk", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
-	{"gpmc_a7.rgmii2_rclk", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"gpmc_a8.rgmii2_rd3", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"gpmc_a9.rgmii2_rd2", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"gpmc_a10.rgmii2_rd1", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"gpmc_a11.rgmii2_rd0", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
-	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
-	{NULL, 0},
-};
-
 /* Module pin mux for mii1 */
 static struct pinmux_config mii1_pin_mux[] = {
 	{"mii1_rxerr.mii1_rxerr", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
@@ -581,44 +274,11 @@ static struct pinmux_config mii1_pin_mux[] = {
 	{NULL, 0},
 };
 
-/* Module pin mux for rmii1 */
-static struct pinmux_config rmii1_pin_mux[] = {
-	{"mii1_crs.rmii1_crs_dv", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_rxerr.mii1_rxerr", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_txen.mii1_txen", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
-	{"mii1_txd1.mii1_txd1", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
-	{"mii1_txd0.mii1_txd0", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
-	{"mii1_rxd1.mii1_rxd1", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_rxd0.mii1_rxd0", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"rmii1_refclk.rmii1_refclk", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
-	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
-	{NULL, 0},
-};
-
 static struct pinmux_config i2c1_pin_mux[] = {
-       {"uart0_ctsn.i2c1_sda",    OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
-                                       AM33XX_PULL_UP | AM33XX_INPUT_EN},
+       {"uart0_ctsn.i2c1_sda", OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
+				AM33XX_PULL_UP | AM33XX_INPUT_EN},
        {"uart0_rtsn.i2c1_scl",   OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
-                                       AM33XX_PULL_UP | AM33XX_INPUT_EN},
-	{NULL, 0},
-};
-
-static struct pinmux_config i2c2_pin_mux[] = {
-	{"uart1_ctsn.i2c2_sda",    OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
-					AM33XX_PULL_UP | AM33XX_INPUT_EN},
-	{"uart1_rtsn.i2c2_scl",   OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
-					AM33XX_PULL_UP | AM33XX_INPUT_EN},
-	{NULL, 0},
-};
-
-/* Module pin mux for mcasp1 */
-static struct pinmux_config mcasp1_pin_mux[] = {
-	{"mii1_crs.mcasp1_aclkx", OMAP_MUX_MODE4 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_rxerr.mcasp1_fsx", OMAP_MUX_MODE4 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"mii1_col.mcasp1_axr2", OMAP_MUX_MODE4 | AM33XX_PIN_INPUT_PULLDOWN},
-	{"rmii1_refclk.mcasp1_axr3", OMAP_MUX_MODE4 |
-						AM33XX_PIN_INPUT_PULLDOWN},
+				AM33XX_PULL_UP | AM33XX_INPUT_EN},
 	{NULL, 0},
 };
 
@@ -634,97 +294,11 @@ static struct pinmux_config mmc0_common_pin_mux[] = {
 	{NULL, 0},
 };
 
-static struct pinmux_config mmc0_wp_only_pin_mux[] = {
-	{"mcasp0_aclkr.gpio3_18", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-
 static struct pinmux_config mmc0_cd_only_pin_mux[] = {
 	{"spi0_cs1.gpio0_6",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
 	{NULL, 0},
 };
 
-/* Module pin mux for mmc1 */
-static struct pinmux_config mmc1_common_pin_mux[] = {
-	{"gpmc_ad3.mmc1_dat3",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_ad2.mmc1_dat2",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_ad1.mmc1_dat1",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_ad0.mmc1_dat0",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_csn1.mmc1_clk",	OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_csn2.mmc1_cmd",	OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-
-static struct pinmux_config mmc1_dat4_7_pin_mux[] = {
-	{"gpmc_ad7.mmc1_dat7",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_ad6.mmc1_dat6",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_ad5.mmc1_dat5",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_ad4.mmc1_dat4",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-
-static struct pinmux_config mmc1_wp_only_pin_mux[] = {
-	{"gpmc_csn0.gpio1_29",	OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-
-static struct pinmux_config mmc1_cd_only_pin_mux[] = {
-	{"gpmc_advn_ale.gpio2_2", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-
-/* Module pin mux for uart3 */
-static struct pinmux_config uart3_pin_mux[] = {
-	{"spi0_cs1.uart3_rxd", AM33XX_PIN_INPUT_PULLUP},
-	{"ecap0_in_pwm0_out.uart3_txd", AM33XX_PULL_ENBL},
-	{NULL, 0},
-};
-
-static struct pinmux_config d_can_gp_pin_mux[] = {
-	{"uart0_ctsn.d_can1_tx", OMAP_MUX_MODE2 | AM33XX_PULL_ENBL},
-	{"uart0_rtsn.d_can1_rx", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-
-static struct pinmux_config d_can_ia_pin_mux[] = {
-	{"uart0_rxd.d_can0_tx", OMAP_MUX_MODE2 | AM33XX_PULL_ENBL},
-	{"uart0_txd.d_can0_rx", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-
-/* Module pin mux for uart2 */
-static struct pinmux_config uart2_pin_mux[] = {
-	{"spi0_sclk.uart2_rxd", OMAP_MUX_MODE1 | AM33XX_SLEWCTRL_SLOW |
-						AM33XX_PIN_INPUT_PULLUP},
-	{"spi0_d0.uart2_txd", OMAP_MUX_MODE1 | AM33XX_PULL_UP |
-						AM33XX_PULL_DISA |
-						AM33XX_SLEWCTRL_SLOW},
-	{NULL, 0},
-};
-
-/* pinmux for gpio based key */
-static struct pinmux_config gpio_keys_pin_mux[] = {
-	{"gpmc_wait0.gpio0_30", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"gpmc_oen_ren.gpio2_3", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"gpmc_advn_ale.gpio2_2", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"gpmc_ben0_cle.gpio2_5", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{NULL, 0},
-};
-
-/* pinmux for led device */
-static struct pinmux_config gpio_led_mux[] = {
-	{"gpmc_ad4.gpio1_4", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"gpmc_ad5.gpio1_5", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"gpmc_ad6.gpio1_6", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"gpmc_ad7.gpio1_7", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{NULL, 0},
-};
-
-static struct pinmux_config gpio_ddr_vtt_enb_pin_mux[] = {
-	{"ecap0_in_pwm0_out.gpio0_7", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
-	{NULL, 0},
-};
-
 /*
 * @pin_mux - single module pin-mux structure which defines pin-mux
 *			details for all its pins.
@@ -738,167 +312,6 @@ static void setup_pin_mux(struct pinmux_config *pin_mux)
 
 }
 
-/* Matrix GPIO Keypad Support for profile-0 only: TODO */
-
-/* pinmux for keypad device */
-static struct pinmux_config matrix_keypad_pin_mux[] = {
-	{"gpmc_a5.gpio1_21",  OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
-	{"gpmc_a6.gpio1_22",  OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
-	{"gpmc_a9.gpio1_25",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"gpmc_a10.gpio1_26", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"gpmc_a11.gpio1_27", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{NULL, 0},
-};
-
-/* Keys mapping */
-static const uint32_t am335x_evm_matrix_keys[] = {
-	KEY(0, 0, KEY_MENU),
-	KEY(1, 0, KEY_BACK),
-	KEY(2, 0, KEY_LEFT),
-
-	KEY(0, 1, KEY_RIGHT),
-	KEY(1, 1, KEY_ENTER),
-	KEY(2, 1, KEY_DOWN),
-};
-
-const struct matrix_keymap_data am335x_evm_keymap_data = {
-	.keymap      = am335x_evm_matrix_keys,
-	.keymap_size = ARRAY_SIZE(am335x_evm_matrix_keys),
-};
-
-static const unsigned int am335x_evm_keypad_row_gpios[] = {
-	GPIO_TO_PIN(1, 25), GPIO_TO_PIN(1, 26), GPIO_TO_PIN(1, 27)
-};
-
-static const unsigned int am335x_evm_keypad_col_gpios[] = {
-	GPIO_TO_PIN(1, 21), GPIO_TO_PIN(1, 22)
-};
-
-static struct matrix_keypad_platform_data am335x_evm_keypad_platform_data = {
-	.keymap_data       = &am335x_evm_keymap_data,
-	.row_gpios         = am335x_evm_keypad_row_gpios,
-	.num_row_gpios     = ARRAY_SIZE(am335x_evm_keypad_row_gpios),
-	.col_gpios         = am335x_evm_keypad_col_gpios,
-	.num_col_gpios     = ARRAY_SIZE(am335x_evm_keypad_col_gpios),
-	.active_low        = false,
-	.debounce_ms       = 5,
-	.col_scan_delay_us = 2,
-};
-
-static struct platform_device am335x_evm_keyboard = {
-	.name  = "matrix-keypad",
-	.id    = -1,
-	.dev   = {
-		.platform_data = &am335x_evm_keypad_platform_data,
-	},
-};
-
-static void matrix_keypad_init(int evm_id, int profile)
-{
-	int err;
-
-	setup_pin_mux(matrix_keypad_pin_mux);
-	err = platform_device_register(&am335x_evm_keyboard);
-	if (err) {
-		pr_err("failed to register matrix keypad (2x3) device\n");
-	}
-}
-
-
-/* pinmux for keypad device */
-static struct pinmux_config volume_keys_pin_mux[] = {
-	{"spi0_sclk.gpio0_2",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"spi0_d0.gpio0_3",    OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{NULL, 0},
-};
-
-/* Configure GPIOs for Volume Keys */
-static struct gpio_keys_button am335x_evm_volume_gpio_buttons[] = {
-	{
-		.code                   = KEY_VOLUMEUP,
-		.gpio                   = GPIO_TO_PIN(0, 2),
-		.active_low             = true,
-		.desc                   = "volume-up",
-		.type                   = EV_KEY,
-		.wakeup                 = 1,
-	},
-	{
-		.code                   = KEY_VOLUMEDOWN,
-		.gpio                   = GPIO_TO_PIN(0, 3),
-		.active_low             = true,
-		.desc                   = "volume-down",
-		.type                   = EV_KEY,
-		.wakeup                 = 1,
-	},
-};
-
-static struct gpio_keys_platform_data am335x_evm_volume_gpio_key_info = {
-	.buttons        = am335x_evm_volume_gpio_buttons,
-	.nbuttons       = ARRAY_SIZE(am335x_evm_volume_gpio_buttons),
-};
-
-static struct platform_device am335x_evm_volume_keys = {
-	.name   = "gpio-keys",
-	.id     = -1,
-	.dev    = {
-		.platform_data  = &am335x_evm_volume_gpio_key_info,
-	},
-};
-
-static void volume_keys_init(int evm_id, int profile)
-{
-	int err;
-
-	setup_pin_mux(volume_keys_pin_mux);
-	err = platform_device_register(&am335x_evm_volume_keys);
-	if (err)
-		pr_err("failed to register matrix keypad (2x3) device\n");
-}
-
-/*
-* @evm_id - evm id which needs to be configured
-* @dev_cfg - single evm structure which includes
-*				all module inits, pin-mux defines
-* @profile - if present, else PROFILE_NONE
-* @dghtr_brd_flg - Whether Daughter board is present or not
-*/
-static void _configure_device(int evm_id, struct evm_dev_cfg *dev_cfg,
-	int profile)
-{
-	int i;
-
-	am335x_evm_set_id(evm_id);
-
-	/*
-	* Only General Purpose & Industrial Auto Motro Control
-	* EVM has profiles. So check if this evm has profile.
-	* If not, ignore the profile comparison
-	*/
-
-	/*
-	* If the device is on baseboard, directly configure it. Else (device on
-	* Daughter board), check if the daughter card is detected.
-	*/
-	if (profile == PROFILE_NONE) {
-		for (i = 0; dev_cfg->device_init != NULL; dev_cfg++) {
-			if (dev_cfg->device_on == DEV_ON_BASEBOARD)
-				dev_cfg->device_init(evm_id, profile);
-			else if (daughter_brd_detected == true)
-				dev_cfg->device_init(evm_id, profile);
-		}
-	} else {
-		for (i = 0; dev_cfg->device_init != NULL; dev_cfg++) {
-			if (dev_cfg->profile & profile) {
-				if (dev_cfg->device_on == DEV_ON_BASEBOARD)
-					dev_cfg->device_init(evm_id, profile);
-				else if (daughter_brd_detected == true)
-					dev_cfg->device_init(evm_id, profile);
-			}
-		}
-	}
-}
-
-
 /* pinmux for usb0 drvvbus */
 static struct pinmux_config usb0_pin_mux[] = {
 	{"usb0_drvvbus.usb0_drvvbus",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
@@ -911,141 +324,6 @@ static struct pinmux_config usb1_pin_mux[] = {
 	{NULL, 0},
 };
 
-/* pinmux for profibus */
-static struct pinmux_config profibus_pin_mux[] = {
-	{"uart1_rxd.pr1_uart0_rxd_mux1", OMAP_MUX_MODE5 | AM33XX_PIN_INPUT},
-	{"uart1_txd.pr1_uart0_txd_mux1", OMAP_MUX_MODE5 | AM33XX_PIN_OUTPUT},
-	{"mcasp0_fsr.pr1_pru0_pru_r30_5", OMAP_MUX_MODE5 | AM33XX_PIN_OUTPUT},
-	{NULL, 0},
-};
-
-/* Module pin mux for eCAP0 */
-static struct pinmux_config ecap0_pin_mux[] = {
-	{"ecap0_in_pwm0_out.ecap0_in_pwm0_out",
-		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
-	{NULL, 0},
-};
-
-/* Module pin mux for eCAP */
-static struct pinmux_config ecap2_pin_mux[] = {
-	{"mcasp0_ahclkr.ecap2_in_pwm2_out", AM33XX_PIN_OUTPUT},
-	{NULL, 0},
-};
-
-#define AM335XEVM_WLAN_PMENA_GPIO	GPIO_TO_PIN(1, 30)
-#define AM335XEVM_WLAN_IRQ_GPIO		GPIO_TO_PIN(3, 17)
-#define AM335XEVM_SK_WLAN_IRQ_GPIO      GPIO_TO_PIN(1, 29)
-
-struct wl12xx_platform_data am335xevm_wlan_data = {
-	.irq = OMAP_GPIO_IRQ(AM335XEVM_WLAN_IRQ_GPIO),
-	.board_ref_clock = WL12XX_REFCLOCK_38_XTAL, /* 38.4Mhz */
-	.bt_enable_gpio = GPIO_TO_PIN(3, 21),
-	.wlan_enable_gpio = GPIO_TO_PIN(1, 16),
-};
-
-/* Module pin mux for wlan and bluetooth */
-static struct pinmux_config mmc2_wl12xx_pin_mux[] = {
-	{"gpmc_a1.mmc2_dat0", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_a2.mmc2_dat1", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_a3.mmc2_dat2", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_ben1.mmc2_dat3", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_csn3.mmc2_cmd", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
-	{"gpmc_clk.mmc2_clk", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-
-static struct pinmux_config uart1_wl12xx_pin_mux[] = {
-	{"uart1_ctsn.uart1_ctsn", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
-	{"uart1_rtsn.uart1_rtsn", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT},
-	{"uart1_rxd.uart1_rxd", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
-	{"uart1_txd.uart1_txd", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL},
-	{NULL, 0},
-};
-
-static struct pinmux_config wl12xx_pin_mux[] = {
-	{"gpmc_a0.gpio1_16", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
-	{"mcasp0_ahclkr.gpio3_17", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"mcasp0_ahclkx.gpio3_21", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT_PULLUP},
-	{NULL, 0},
- };
-
-static struct pinmux_config wl12xx_pin_mux_sk[] = {
-	{"gpmc_wpn.gpio0_31", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
-	{"gpmc_csn0.gpio1_29", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
-	{"mcasp0_ahclkx.gpio3_21", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
-	{NULL, 0},
-};
-
-static bool backlight_enable;
-
-static void enable_ecap0(int evm_id, int profile)
-{
-	backlight_enable = true;
-	setup_pin_mux(ecap0_pin_mux);
-}
-
-static void enable_ecap2(int evm_id, int profile)
-{
-	backlight_enable = true;
-	setup_pin_mux(ecap2_pin_mux);
-}
-
-/* Setup pwm-backlight */
-static struct platform_device am335x_backlight = {
-	.name           = "pwm-backlight",
-	.id             = -1,
-	.dev		= {
-		.platform_data = &am335x_backlight_data0,
-	},
-};
-
-static struct pwmss_platform_data  pwm_pdata[3] = {
-	{
-		.version = PWM_VERSION_1,
-	},
-	{
-		.version = PWM_VERSION_1,
-	},
-	{
-		.version = PWM_VERSION_1,
-	},
-};
-
-static int __init backlight_init(void)
-{
-	int status = 0;
-
-	if (backlight_enable) {
-		int ecap_index = 0;
-
-		switch (am335x_evm_get_id()) {
-		case GEN_PURP_EVM:
-		case GEN_PURP_DDR3_EVM:
-			ecap_index = 0;
-			break;
-		case EVM_SK:
-			/*
-			 * Invert polarity of PWM wave from ECAP to handle
-			 * backlight intensity to pwm brightness
-			 */
-			ecap_index = 2;
-			pwm_pdata[ecap_index].chan_attrib[0].inverse_pol = true;
-			am335x_backlight.dev.platform_data =
-				&am335x_backlight_data2;
-			break;
-		default:
-			pr_err("%s: Error on attempting to enable backlight,"
-				" not supported\n", __func__);
-			return -EINVAL;
-		}
-
-		am33xx_register_ecap(ecap_index, &pwm_pdata[ecap_index]);
-		platform_device_register(&am335x_backlight);
-	}
-	return status;
-}
-late_initcall(backlight_init);
-
 static int __init conf_disp_pll(int rate)
 {
 	struct clk *disp_pll;
@@ -1068,10 +346,10 @@ out:
 #define LCD_DATA_ENABLE GPIO_TO_PIN(1,25)
 #define LCD_LVDS_NSHUTDOWN GPIO_TO_PIN(1,26)
 
-static void lcdc_init(int evm_id, int profile)
+static void lcdc_init(void)
 {
 	struct da8xx_lcdc_platform_data *lcdc_pdata;
-        int r;
+	int r;
 	setup_pin_mux(lcdc_pin_mux);
 
 	if (conf_disp_pll(300000000)) {
@@ -1079,922 +357,250 @@ static void lcdc_init(int evm_id, int profile)
 				"register LCDC\n");
 		return;
 	}
-        lcdc_pdata = &EMERGING_pdata;
+	lcdc_pdata = &EMERGING_pdata;
 
 	if (am33xx_register_lcdc(lcdc_pdata))
 		pr_info("Failed to register LCDC device\n");
 
-        omap_mux_init_gpio(LCD_PANEL_PWR, OMAP_PIN_OUTPUT);
-        omap_mux_init_gpio(LCD_PANEL_PWM, OMAP_PIN_OUTPUT);
-        omap_mux_init_gpio(LCD_DATA_ENABLE, OMAP_PIN_OUTPUT);
-        omap_mux_init_gpio(LCD_LVDS_NSHUTDOWN, OMAP_PIN_OUTPUT);
-        /*
-         * Enable LCD 
-         */
-        r = gpio_request(LCD_DATA_ENABLE, "lcd_ena");
-        if (r) {
-                printk(KERN_ERR "failed to get lcd_ena\n");
-                return;
-        }
-        gpio_direction_output(LCD_DATA_ENABLE, 1);
-        gpio_set_value(LCD_DATA_ENABLE,0);
-        gpio_export(LCD_DATA_ENABLE,0);
-        
-        /*
-         * Disable LVDS
-         */
-        r = gpio_request(LCD_LVDS_NSHUTDOWN, "lcd_lvds");
-        if (r) {
-                printk(KERN_ERR "failed to get lcd_lvds\n");
-                return;
-        }
-        gpio_direction_output(LCD_LVDS_NSHUTDOWN, 1);
-        gpio_set_value(LCD_LVDS_NSHUTDOWN,0);
-        gpio_export(LCD_LVDS_NSHUTDOWN,0);
-        /*
-         * Enable LCD Panel PWR
-         */
-        r = gpio_request(LCD_PANEL_PWR, "lcd_pwr");
-        if (r) {
-                printk(KERN_ERR "failed to get lcd_pwr\n");
-                return;
-        }
-        gpio_direction_output(LCD_PANEL_PWR, 1);
-        gpio_set_value(LCD_PANEL_PWR,1);
-        gpio_export(LCD_PANEL_PWR,0);
-        /*
-         * Enable LCD Panel PWM
-         */
-        r = gpio_request(LCD_PANEL_PWM, "lcd_pwm");
-        if (r) {
-                printk(KERN_ERR "failed to get lcd_pwm\n");
-                return;
-        }
-        gpio_direction_output(LCD_PANEL_PWM, 0);
-        gpio_set_value(LCD_PANEL_PWM,0);
-        gpio_export(LCD_PANEL_PWM,0);
-
-        printk(KERN_INFO "Display initialized successfully\n");
-
-
-	return;
-}
+	omap_mux_init_gpio(LCD_PANEL_PWR, OMAP_PIN_OUTPUT);
+	omap_mux_init_gpio(LCD_PANEL_PWM, OMAP_PIN_OUTPUT);
+	omap_mux_init_gpio(LCD_DATA_ENABLE, OMAP_PIN_OUTPUT);
+	omap_mux_init_gpio(LCD_LVDS_NSHUTDOWN, OMAP_PIN_OUTPUT);
+	/*
+	 * Enable LCD
+	 */
+	r = gpio_request(LCD_DATA_ENABLE, "lcd_ena");
+	if (r) {
+		printk(KERN_ERR "failed to get lcd_ena\n");
+		return;
+	}
+	gpio_direction_output(LCD_DATA_ENABLE, 1);
+	gpio_set_value(LCD_DATA_ENABLE,0);
+	gpio_export(LCD_DATA_ENABLE,0);
 
-static void mfd_tscadc_init(int evm_id, int profile)
-{
-	int err;
-
-	err = am33xx_register_mfd_tscadc(&tscadc);
-	if (err)
-		pr_err("failed to register touchscreen device\n");
-}
-
-static void rgmii1_init(int evm_id, int profile)
-{
-	setup_pin_mux(rgmii1_pin_mux);
-	return;
-}
-
-static void rgmii2_init(int evm_id, int profile)
-{
-	setup_pin_mux(rgmii2_pin_mux);
-	return;
-}
-
-static void mii1_init(int evm_id, int profile)
-{
-	setup_pin_mux(mii1_pin_mux);
-	return;
-}
-
-static void rmii1_init(int evm_id, int profile)
-{
-	setup_pin_mux(rmii1_pin_mux);
-	return;
-}
-
-static void usb0_init(int evm_id, int profile)
-{
-	setup_pin_mux(usb0_pin_mux);
-	return;
-}
-
-static void usb1_init(int evm_id, int profile)
-{
-	setup_pin_mux(usb1_pin_mux);
-	return;
-}
-
-/* setup uart3 */
-static void uart3_init(int evm_id, int profile)
-{
-	setup_pin_mux(uart3_pin_mux);
-	return;
-}
-
-/* setup uart2 */
-static void uart2_init(int evm_id, int profile)
-{
-	setup_pin_mux(uart2_pin_mux);
-	return;
-}
-
-/*
- * gpio0_7 was driven HIGH in u-boot before DDR configuration
- *
- * setup gpio0_7 for EVM-SK 1.2
- */
-static void gpio_ddr_vtt_enb_init(int evm_id, int profile)
-{
-	setup_pin_mux(gpio_ddr_vtt_enb_pin_mux);
-	return;
-}
-
-/* setup haptics */
-#define HAPTICS_MAX_FREQ 250
-static void haptics_init(int evm_id, int profile)
-{
-	setup_pin_mux(haptics_pin_mux);
-	pwm_pdata[2].chan_attrib[1].max_freq = HAPTICS_MAX_FREQ;
-	am33xx_register_ehrpwm(2, &pwm_pdata[2]);
-}
-
-/* NAND partition information */
-static struct mtd_partition am335x_nand_partitions[] = {
-/* All the partition sizes are listed in terms of NAND block size */
-	{
-		.name           = "xloader-nand",
-		.offset         = 0,			/* Offset = 0x0 */
-		.size           = 4*(SZ_128K),
-		.mask_flags     = MTD_WRITEABLE
-	},
-	{
-		.name           = "uboot-nand",
-		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x80000 */
-		.size           = 15*(SZ_128K),
-		.mask_flags     = MTD_WRITEABLE
-	},
-	{
-		.name           = "params-nand",
-		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x260000 */
-		.size           = 1*(SZ_128K)
-	},
-	{
-		.name           = "linux-nand",
-		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x280000 */
-		.size           = 40*(SZ_128K)
-	},
-	{
-		.name           = "jffs2-nand",
-		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x780000 */
-		.size           = 1040*(SZ_128K),	/*130MB*/
-	},
-	{
-		.name           = "usr-nand",
-		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x8980000 */
-		.size           = MTDPART_SIZ_FULL,
-	},
-};
-
-#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
-#define ADS7846_IRQ            GPIO_TO_PIN(1,22)
-/* Module pin mux for wlan and bluetooth */
-static struct pinmux_config ads7846_pin_mux[] = {
-	{"gpmc_a6.gpio1_22", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
-	{NULL, 0},
-};
-static void am335x_bytepanel_ads7846_init(void)
-{
-        int r;
-	setup_pin_mux(ads7846_pin_mux);
-        r = gpio_request(ADS7846_IRQ, "ads7846_pendown_irq");
-        if (r) {
-                printk(KERN_ERR "failed to get ads7846_irq\n");
-                return;
-        }
-        gpio_direction_input(ADS7846_IRQ);
-}
-
-static int am335x_bytepanel_ads7846_pendown_state(void)
-{
-        return !gpio_get_value(ADS7846_IRQ);      /* Touchscreen PENIRQ */
-}
-static struct ads7846_platform_data ads_info = {
-        .model                  = 7846,
-        .x_max                  = 0x0fff,
-        .y_max                  = 0x0fff,
-        .x_plate_ohms           = 180,
-        .pressure_max           = 255,
-        .debounce_max           = 10,
-        .debounce_rep           = 0,
-        .debounce_tol           = 3,
-        .get_pendown_state      = am335x_bytepanel_ads7846_pendown_state,
-        .keep_vref_on           = 1,
-};
-#endif
-static struct spi_board_info am335x_spi0_slave_info[] = {
-#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
-        {
-                .modalias       = "ads7846",
-                .bus_num        = 1,
-                .chip_select    = 0,
-                .max_speed_hz   = 1500000,
-                .platform_data  = &ads_info,
-                .irq            = OMAP_GPIO_IRQ(ADS7846_IRQ),
-        },
-#endif
-};
-
-static struct spi_board_info am335x_spi1_slave_info[] = {
-};
-
-#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
-static struct pinmux_config ft5x06_pin_mux[] = {
-	{"gpmc_a7.gpio1_23", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},	/* /WAKE */
-	{"gpmc_a8.gpio1_24", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},	/*/INT */
-	{NULL, 0},
-};
-
-static void am335x_bytepanel_ft5x06_init(void)
-{
-	setup_pin_mux(ft5x06_pin_mux);
-}
-#endif
-
-static struct gpmc_timings am335x_nand_timings = {
-	.sync_clk = 0,
-
-	.cs_on = 0,
-	.cs_rd_off = 44,
-	.cs_wr_off = 44,
-
-	.adv_on = 6,
-	.adv_rd_off = 34,
-	.adv_wr_off = 44,
-	.we_off = 40,
-	.oe_off = 54,
-
-	.access = 64,
-	.rd_cycle = 82,
-	.wr_cycle = 82,
-
-	.wr_access = 40,
-	.wr_data_mux_bus = 0,
-};
-
-static void evm_nand_init(int evm_id, int profile)
-{
-	struct omap_nand_platform_data *pdata;
-	struct gpmc_devices_info gpmc_device[2] = {
-		{ NULL, 0 },
-		{ NULL, 0 },
-	};
-
-	setup_pin_mux(nand_pin_mux);
-	pdata = omap_nand_init(am335x_nand_partitions,
-		ARRAY_SIZE(am335x_nand_partitions), 0, 0,
-		&am335x_nand_timings);
-	if (!pdata)
-		return;
-	pdata->ecc_opt = OMAP_ECC_BCH4_CODE_HW;
-	pdata->elm_used = true;
-	gpmc_device[0].pdata = pdata;
-	gpmc_device[0].flag = GPMC_DEVICE_NAND;
-
-	omap_init_gpmc(gpmc_device, sizeof(gpmc_device));
-	omap_init_elm();
-}
-
-/* TPS65217 voltage regulator support */
-
-/* 1.8V */
-static struct regulator_consumer_supply tps65217_dcdc1_consumers[] = {
-	{
-		.supply = "vdds_osc",
-	},
-	{
-		.supply = "vdds_pll_ddr",
-	},
-	{
-		.supply = "vdds_pll_mpu",
-	},
-	{
-		.supply = "vdds_pll_core_lcd",
-	},
-	{
-		.supply = "vdds_sram_mpu_bb",
-	},
-	{
-		.supply = "vdds_sram_core_bg",
-	},
-	{
-		.supply = "vdda_usb0_1p8v",
-	},
-	{
-		.supply = "vdds_ddr",
-	},
-	{
-		.supply = "vdds",
-	},
-	{
-		.supply = "vdds_hvx_1p8v",
-	},
-	{
-		.supply = "vdda_adc",
-	},
-	{
-		.supply = "ddr2",
-	},
-};
-
-/* 1.1V */
-static struct regulator_consumer_supply tps65217_dcdc2_consumers[] = {
-	{
-		.supply = "vdd_mpu",
-	},
-};
-
-/* 1.1V */
-static struct regulator_consumer_supply tps65217_dcdc3_consumers[] = {
-	{
-		.supply = "vdd_core",
-	},
-};
-
-/* 1.8V LDO */
-static struct regulator_consumer_supply tps65217_ldo1_consumers[] = {
-	{
-		.supply = "vdds_rtc",
-	},
-};
-
-/* 3.3V LDO */
-static struct regulator_consumer_supply tps65217_ldo2_consumers[] = {
-	{
-		.supply = "vdds_any_pn",
-	},
-};
-
-/* 3.3V LDO */
-static struct regulator_consumer_supply tps65217_ldo3_consumers[] = {
-	{
-		.supply = "vdds_hvx_ldo3_3p3v",
-	},
-	{
-		.supply = "vdda_usb0_3p3v",
-	},
-};
-
-/* 3.3V LDO */
-static struct regulator_consumer_supply tps65217_ldo4_consumers[] = {
-	{
-		.supply = "vdds_hvx_ldo4_3p3v",
-	},
-};
-
-/*
- * FIXME: Some BeagleBones reuire a ramp_delay to settle down the set
- * voltage from 0.95v to 1.25v. By default a minimum of 70msec is set
- * based on experimentation. This will be removed/modified to exact
- * value, once the root cause is known.
- *
- * The reason for extended ramp time requirement on BeagleBone is not
- * known and the delay varies from board - board, if the board hangs
- * with this 70msec delay then try to increase the value.
- */
-static struct tps65217_rdelay dcdc2_ramp_delay = {
-	.ramp_delay = 70000,
-};
-
-static struct regulator_init_data tps65217_regulator_data[] = {
-	/* dcdc1 */
-	{
-		.constraints = {
-			.min_uV = 900000,
-			.max_uV = 1800000,
-			.boot_on = 1,
-			.always_on = 1,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(tps65217_dcdc1_consumers),
-		.consumer_supplies = tps65217_dcdc1_consumers,
-	},
-
-	/* dcdc2 */
-	{
-		.constraints = {
-			.min_uV = 900000,
-			.max_uV = 3300000,
-			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
-				REGULATOR_CHANGE_STATUS),
-			.boot_on = 1,
-			.always_on = 1,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(tps65217_dcdc2_consumers),
-		.consumer_supplies = tps65217_dcdc2_consumers,
-		.driver_data = &dcdc2_ramp_delay,
-	},
-
-	/* dcdc3 */
-	{
-		.constraints = {
-			.min_uV = 900000,
-			.max_uV = 1500000,
-			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
-				REGULATOR_CHANGE_STATUS),
-			.boot_on = 1,
-			.always_on = 1,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(tps65217_dcdc3_consumers),
-		.consumer_supplies = tps65217_dcdc3_consumers,
-	},
-
-	/* ldo1 */
-	{
-		.constraints = {
-			.min_uV = 1000000,
-			.max_uV = 3300000,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS,
-			.boot_on = 1,
-			.always_on = 1,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(tps65217_ldo1_consumers),
-		.consumer_supplies = tps65217_ldo1_consumers,
-	},
-
-	/* ldo2 */
-	{
-		.constraints = {
-			.min_uV = 900000,
-			.max_uV = 3300000,
-			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
-				REGULATOR_CHANGE_STATUS),
-			.boot_on = 1,
-			.always_on = 1,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(tps65217_ldo2_consumers),
-		.consumer_supplies = tps65217_ldo2_consumers,
-	},
-
-	/* ldo3 */
-	{
-		.constraints = {
-			.min_uV = 1800000,
-			.max_uV = 3300000,
-			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
-				REGULATOR_CHANGE_STATUS),
-			.boot_on = 1,
-			.always_on = 1,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(tps65217_ldo3_consumers),
-		.consumer_supplies = tps65217_ldo3_consumers,
-	},
-
-	/* ldo4 */
-	{
-		.constraints = {
-			.min_uV = 1800000,
-			.max_uV = 3300000,
-			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
-				REGULATOR_CHANGE_STATUS),
-			.boot_on = 1,
-			.always_on = 1,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(tps65217_ldo4_consumers),
-		.consumer_supplies = tps65217_ldo4_consumers,
-	},
-};
-
-static struct tps65217_board beaglebone_tps65217_info = {
-	.tps65217_init_data = &tps65217_regulator_data[0],
-	.status_off = true,
-};
-
-static struct lis3lv02d_platform_data lis331dlh_pdata = {
-	.click_flags = LIS3_CLICK_SINGLE_X |
-			LIS3_CLICK_SINGLE_Y |
-			LIS3_CLICK_SINGLE_Z,
-	.wakeup_flags = LIS3_WAKEUP_X_LO | LIS3_WAKEUP_X_HI |
-			LIS3_WAKEUP_Y_LO | LIS3_WAKEUP_Y_HI |
-			LIS3_WAKEUP_Z_LO | LIS3_WAKEUP_Z_HI,
-	.irq_cfg = LIS3_IRQ1_CLICK | LIS3_IRQ2_CLICK,
-	.wakeup_thresh	= 10,
-	.click_thresh_x = 10,
-	.click_thresh_y = 10,
-	.click_thresh_z = 10,
-	.g_range	= 2,
-	.st_min_limits[0] = 120,
-	.st_min_limits[1] = 120,
-	.st_min_limits[2] = 140,
-	.st_max_limits[0] = 550,
-	.st_max_limits[1] = 550,
-	.st_max_limits[2] = 750,
-};
-
-static struct i2c_board_info lis331dlh_i2c_boardinfo[] = {
-	{
-		I2C_BOARD_INFO("lis331dlh", 0x18),
-		.platform_data = &lis331dlh_pdata,
-	},
-};
-
-static void lis331dlh_init(int evm_id, int profile)
-{
-	struct i2c_adapter *adapter;
-	struct i2c_client *client;
-	unsigned int i2c_instance;
-
-	switch (evm_id) {
-	case GEN_PURP_EVM:
-	case GEN_PURP_DDR3_EVM:
-		i2c_instance = 2;
-		break;
-	case EVM_SK:
-		i2c_instance = 1;
-		break;
-	default:
-		pr_err("lis331dlh is not supported on this evm (%d)\n", evm_id);
+	/*
+	 * Disable LVDS
+	 */
+	r = gpio_request(LCD_LVDS_NSHUTDOWN, "lcd_lvds");
+	if (r) {
+		printk(KERN_ERR "failed to get lcd_lvds\n");
 		return;
 	}
-
-	/* I2C adapter request */
-	adapter = i2c_get_adapter(i2c_instance);
-	if (!adapter) {
-		pr_err("failed to get adapter i2c%u\n", i2c_instance);
+	gpio_direction_output(LCD_LVDS_NSHUTDOWN, 1);
+	gpio_set_value(LCD_LVDS_NSHUTDOWN,0);
+	gpio_export(LCD_LVDS_NSHUTDOWN,0);
+	/*
+	 * Enable LCD Panel PWR
+	 */
+	r = gpio_request(LCD_PANEL_PWR, "lcd_pwr");
+	if (r) {
+		printk(KERN_ERR "failed to get lcd_pwr\n");
 		return;
 	}
-
-	client = i2c_new_device(adapter, lis331dlh_i2c_boardinfo);
-	if (!client)
-		pr_err("failed to register lis331dlh to i2c%u\n", i2c_instance);
-
-	i2c_put_adapter(adapter);
-}
-
-static struct i2c_board_info __initdata am335x_i2c1_boardinfo[] = {
-#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
-	{
-		I2C_BOARD_INFO("edt-ft5x06", 0x38),
-		.platform_data = &am335x_touchscreen_edt_data,
-		.irq = OMAP_GPIO_IRQ(FT5X06_IRQ),
-	},
-#endif
-};
-
-static void i2c1_init(int evm_id, int profile)
-{
-	setup_pin_mux(i2c1_pin_mux);
-	omap_register_i2c_bus(2, 100, am335x_i2c1_boardinfo,
-			ARRAY_SIZE(am335x_i2c1_boardinfo));
-	return;
-}
-
-static struct i2c_board_info am335x_i2c2_boardinfo[] = {
-};
-
-static void i2c2_init(int evm_id, int profile)
-{
-	setup_pin_mux(i2c2_pin_mux);
-	omap_register_i2c_bus(3, 100, am335x_i2c2_boardinfo,
-			ARRAY_SIZE(am335x_i2c2_boardinfo));
-	return;
-}
-
-/* Setup McASP 1 */
-static void mcasp1_init(int evm_id, int profile)
-{
-	/* Configure McASP */
-	setup_pin_mux(mcasp1_pin_mux);
-	switch (evm_id) {
-	case EVM_SK:
-		am335x_register_mcasp(&am335x_evm_sk_snd_data1, 1);
-		break;
-	default:
-		am335x_register_mcasp(&am335x_evm_snd_data1, 1);
-	}
-
-	return;
-}
-
-static void mmc1_init(int evm_id, int profile)
-{
-	setup_pin_mux(mmc1_common_pin_mux);
-	setup_pin_mux(mmc1_dat4_7_pin_mux);
-	setup_pin_mux(mmc1_wp_only_pin_mux);
-	setup_pin_mux(mmc1_cd_only_pin_mux);
-
-	am335x_mmc[1].mmc = 2;
-	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA;
-	am335x_mmc[1].gpio_cd = GPIO_TO_PIN(2, 2);
-	am335x_mmc[1].gpio_wp = GPIO_TO_PIN(1, 29);
-	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
-
-	/* mmc will be initialized when mmc0_init is called */
-	return;
-}
-
-static void mmc1_wl12xx_init(int evm_id, int profile)
-{
-	setup_pin_mux(mmc1_common_pin_mux);
-	am335x_mmc[1].mmc = 2;
-	am335x_mmc[1].name = "wl1271";
-	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD;
-	am335x_mmc[1].nonremovable = true;
-	am335x_mmc[1].gpio_cd = -EINVAL;
-	am335x_mmc[1].gpio_wp = -EINVAL;
-	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
-}
-
-static void mmc2_wl12xx_init(int evm_id, int profile)
-{
-	setup_pin_mux(mmc2_wl12xx_pin_mux);
-
-	am335x_mmc[1].mmc = 3;
-	am335x_mmc[1].name = "wl1271";
-	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD;
-	am335x_mmc[1].nonremovable = true;
-	am335x_mmc[1].gpio_cd = -EINVAL;
-	am335x_mmc[1].gpio_wp = -EINVAL;
-	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
-
-	/* mmc will be initialized when mmc0_init is called */
-	return;
-}
-
-static void uart1_wl12xx_init(int evm_id, int profile)
-{
-	setup_pin_mux(uart1_wl12xx_pin_mux);
-}
-
-static void wl12xx_bluetooth_enable(void)
-{
-	int status = gpio_request(am335xevm_wlan_data.bt_enable_gpio,
-		"bt_en\n");
-	if (status < 0)
-		pr_err("Failed to request gpio for bt_enable");
-
-	pr_info("Configure Bluetooth Enable pin...\n");
-	gpio_direction_output(am335xevm_wlan_data.bt_enable_gpio, 0);
-}
-
-static int wl12xx_set_power(struct device *dev, int slot, int on, int vdd)
-{
-	if (on) {
-		gpio_direction_output(am335xevm_wlan_data.wlan_enable_gpio, 1);
-		mdelay(70);
-	} else {
-		gpio_direction_output(am335xevm_wlan_data.wlan_enable_gpio, 0);
-	}
-
-	return 0;
-}
-
-static void wl12xx_init(int evm_id, int profile)
-{
-	struct device *dev;
-	struct omap_mmc_platform_data *pdata;
-	int ret;
-
-	if (evm_id == EVM_SK) {
-		am335xevm_wlan_data.wlan_enable_gpio = GPIO_TO_PIN(0, 31);
-		am335xevm_wlan_data.bt_enable_gpio = GPIO_TO_PIN(3, 21);
-		am335xevm_wlan_data.irq =
-				OMAP_GPIO_IRQ(AM335XEVM_SK_WLAN_IRQ_GPIO);
-		setup_pin_mux(wl12xx_pin_mux_sk);
-	} else {
-		setup_pin_mux(wl12xx_pin_mux);
-	}
-	wl12xx_bluetooth_enable();
-
-	if (wl12xx_set_platform_data(&am335xevm_wlan_data))
-		pr_err("error setting wl12xx data\n");
-
-	dev = am335x_mmc[1].dev;
-	if (!dev) {
-		pr_err("wl12xx mmc device initialization failed\n");
-		goto out;
-	}
-
-	pdata = dev->platform_data;
-	if (!pdata) {
-		pr_err("Platfrom data of wl12xx device not set\n");
-		goto out;
-	}
-
-	ret = gpio_request_one(am335xevm_wlan_data.wlan_enable_gpio,
-		GPIOF_OUT_INIT_LOW, "wlan_en");
-	if (ret) {
-		pr_err("Error requesting wlan enable gpio: %d\n", ret);
-		goto out;
-	}
-
-
-	pdata->slots[0].set_power = wl12xx_set_power;
-out:
-	return;
-}
-
-static void d_can_init(int evm_id, int profile)
-{
-	switch (evm_id) {
-	case IND_AUT_MTR_EVM:
-		if ((profile == PROFILE_0) || (profile == PROFILE_1)) {
-			setup_pin_mux(d_can_ia_pin_mux);
-			/* Instance Zero */
-			am33xx_d_can_init(0);
-		}
-		break;
-	case GEN_PURP_EVM:
-	case GEN_PURP_DDR3_EVM:
-		if (profile == PROFILE_1) {
-			setup_pin_mux(d_can_gp_pin_mux);
-			/* Instance One */
-			am33xx_d_can_init(1);
-		}
-		break;
-	default:
-		break;
-	}
-}
-
-static void mmc0_init(int evm_id, int profile)
-{
-	switch (evm_id) {
-	case BEAGLE_BONE_A3:
-	case BEAGLE_BONE_OLD:
-	case EVM_SK:
-		setup_pin_mux(mmc0_common_pin_mux);
-		setup_pin_mux(mmc0_cd_only_pin_mux);
-		break;
-	default:
-		setup_pin_mux(mmc0_common_pin_mux);
-		setup_pin_mux(mmc0_cd_only_pin_mux);
-		setup_pin_mux(mmc0_wp_only_pin_mux);
-		break;
-	}
-
-	omap2_hsmmc_init(am335x_mmc);
-	return;
-}
-
-static struct i2c_board_info tps65217_i2c_boardinfo[] = {
-	{
-		I2C_BOARD_INFO("tps65217", TPS65217_I2C_ID),
-		.platform_data  = &beaglebone_tps65217_info,
-	},
-};
-
-static void tps65217_init(int evm_id, int profile)
-{
-	struct i2c_adapter *adapter;
-	struct i2c_client *client;
-	struct device *mpu_dev;
-	struct tps65217 *tps;
-	unsigned int val;
-	int ret;
-
-	mpu_dev = omap_device_get_by_hwmod_name("mpu");
-	if (!mpu_dev)
-		pr_warning("%s: unable to get the mpu device\n", __func__);
-
-	/* I2C1 adapter request */
-	adapter = i2c_get_adapter(1);
-	if (!adapter) {
-		pr_err("failed to get adapter i2c1\n");
+	gpio_direction_output(LCD_PANEL_PWR, 1);
+	gpio_set_value(LCD_PANEL_PWR,1);
+	gpio_export(LCD_PANEL_PWR,0);
+	/*
+	 * Enable LCD Panel PWM
+	 */
+	r = gpio_request(LCD_PANEL_PWM, "lcd_pwm");
+	if (r) {
+		printk(KERN_ERR "failed to get lcd_pwm\n");
 		return;
 	}
+	gpio_direction_output(LCD_PANEL_PWM, 0);
+	gpio_set_value(LCD_PANEL_PWM,0);
+	gpio_export(LCD_PANEL_PWM,0);
 
-	client = i2c_new_device(adapter, tps65217_i2c_boardinfo);
-	if (!client)
-		pr_err("failed to register tps65217 to i2c1\n");
-
-	i2c_put_adapter(adapter);
-
-	tps = (struct tps65217 *)i2c_get_clientdata(client);
+	printk(KERN_INFO "Display initialized successfully\n");
 
-	ret = tps65217_reg_read(tps, TPS65217_REG_STATUS, &val);
-	if (ret) {
-		pr_err("failed to read tps65217 status reg\n");
-		return;
-	}
 
-	if (!(val & TPS65217_STATUS_ACPWR)) {
-		/* If powered by USB then disable OPP120 and OPPTURBO */
-		pr_info("Maximum current provided by the USB port is 500mA"
-			" which is not sufficient\nwhen operating @OPP120 and"
-			" OPPTURBO. The current requirement for some\nuse-cases"
-			" using OPP100 might also exceed the maximum current"
-			" that the\nUSB port can provide. Unless you are fully"
-			" confident that the current\nrequirements for OPP100"
-			" use-case don't exceed the USB limits, switching\nto"
-			" AC power is recommended.\n");
-		opp_disable(mpu_dev, 600000000);
-		opp_disable(mpu_dev, 720000000);
-	}
+	return;
 }
 
-static void mmc0_no_cd_init(int evm_id, int profile)
+static void mii1_init(void)
 {
-	setup_pin_mux(mmc0_common_pin_mux);
-	setup_pin_mux(mmc0_wp_only_pin_mux);
+	setup_pin_mux(mii1_pin_mux);
+	return;
+}
 
-	omap2_hsmmc_init(am335x_mmc);
+static void usb0_init(void)
+{
+	setup_pin_mux(usb0_pin_mux);
+	return;
+}
+
+static void usb1_init(void)
+{
+	setup_pin_mux(usb1_pin_mux);
 	return;
 }
 
-/* Configure GPIOs for GPIO Keys */
-static struct gpio_keys_button am335x_evm_gpio_buttons[] = {
+/* NAND partition information */
+static struct mtd_partition am335x_nand_partitions[] = {
+/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name           = "xloader-nand",
+		.offset         = 0,			/* Offset = 0x0 */
+		.size           = 4*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "uboot-nand",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x80000 */
+		.size           = 15*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
 	{
-		.code                   = BTN_0,
-		.gpio                   = GPIO_TO_PIN(2, 3),
-		.desc                   = "SW1",
+		.name           = "params-nand",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x260000 */
+		.size           = 1*(SZ_128K)
 	},
 	{
-		.code                   = BTN_1,
-		.gpio                   = GPIO_TO_PIN(2, 2),
-		.desc                   = "SW2",
+		.name           = "linux-nand",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x280000 */
+		.size           = 40*(SZ_128K)
 	},
 	{
-		.code                   = BTN_2,
-		.gpio                   = GPIO_TO_PIN(0, 30),
-		.desc                   = "SW3",
-		.wakeup                 = 1,
+		.name           = "jffs2-nand",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x780000 */
+		.size           = 1040*(SZ_128K),	/*130MB*/
 	},
 	{
-		.code                   = BTN_3,
-		.gpio                   = GPIO_TO_PIN(2, 5),
-		.desc                   = "SW4",
+		.name           = "usr-nand",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x8980000 */
+		.size           = MTDPART_SIZ_FULL,
 	},
 };
 
-static struct gpio_keys_platform_data am335x_evm_gpio_key_info = {
-	.buttons        = am335x_evm_gpio_buttons,
-	.nbuttons       = ARRAY_SIZE(am335x_evm_gpio_buttons),
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+#define ADS7846_IRQ            GPIO_TO_PIN(1,22)
+/* Module pin mux for wlan and bluetooth */
+static struct pinmux_config ads7846_pin_mux[] = {
+	{"gpmc_a6.gpio1_22", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
 };
+static void am335x_bytepanel_ads7846_init(void)
+{
+	int r;
+	setup_pin_mux(ads7846_pin_mux);
+	r = gpio_request(ADS7846_IRQ, "ads7846_pendown_irq");
+	if (r) {
+		printk(KERN_ERR "failed to get ads7846_irq\n");
+		return;
+	}
+	gpio_direction_input(ADS7846_IRQ);
+}
 
-static struct platform_device am335x_evm_gpio_keys = {
-	.name   = "gpio-keys",
-	.id     = -1,
-	.dev    = {
-		.platform_data  = &am335x_evm_gpio_key_info,
+static int am335x_bytepanel_ads7846_pendown_state(void)
+{
+	return !gpio_get_value(ADS7846_IRQ);      /* Touchscreen PENIRQ */
+}
+static struct ads7846_platform_data ads_info = {
+	.model                  = 7846,
+	.x_max                  = 0x0fff,
+	.y_max                  = 0x0fff,
+	.x_plate_ohms           = 180,
+	.pressure_max           = 255,
+	.debounce_max           = 10,
+	.debounce_rep           = 0,
+	.debounce_tol           = 3,
+	.get_pendown_state      = am335x_bytepanel_ads7846_pendown_state,
+	.keep_vref_on           = 1,
+};
+#endif
+static struct spi_board_info am335x_spi0_slave_info[] = {
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+	{
+		.modalias       = "ads7846",
+		.bus_num        = 1,
+		.chip_select    = 0,
+		.max_speed_hz   = 1500000,
+		.platform_data  = &ads_info,
+		.irq            = OMAP_GPIO_IRQ(ADS7846_IRQ),
 	},
+#endif
 };
 
-static void gpio_keys_init(int evm_id, int profile)
-{
-	int err;
 
-	setup_pin_mux(gpio_keys_pin_mux);
-	err = platform_device_register(&am335x_evm_gpio_keys);
-	if (err)
-		pr_err("failed to register gpio key device\n");
+#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+static struct pinmux_config ft5x06_pin_mux[] = {
+	{"gpmc_a7.gpio1_23", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},	/* /WAKE */
+	{"gpmc_a8.gpio1_24", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},	/*/INT */
+	{NULL, 0},
+};
+
+static void am335x_bytepanel_ft5x06_init(void)
+{
+	setup_pin_mux(ft5x06_pin_mux);
 }
+#endif
 
-static struct gpio_led gpio_leds[] = {
-	{
-		.name			= "am335x:EVM_SK:usr0",
-		.gpio			= GPIO_TO_PIN(1, 4),	/* D1 */
-	},
-	{
-		.name			= "am335x:EVM_SK:usr1",
-		.gpio			= GPIO_TO_PIN(1, 5),	/* D2 */
-	},
-	{
-		.name			= "am335x:EVM_SK:mmc0",
-		.gpio			= GPIO_TO_PIN(1, 7),	/* D3 */
-		.default_trigger	= "mmc0",
-	},
-	{
-		.name			= "am335x:EVM_SK:heartbeat",
-		.gpio			= GPIO_TO_PIN(1, 6),	/* D4 */
-		.default_trigger	= "heartbeat",
-	},
-};
+static struct gpmc_timings am335x_nand_timings = {
+	.sync_clk = 0,
+
+	.cs_on = 0,
+	.cs_rd_off = 44,
+	.cs_wr_off = 44,
+
+	.adv_on = 6,
+	.adv_rd_off = 34,
+	.adv_wr_off = 44,
+	.we_off = 40,
+	.oe_off = 54,
 
-static struct gpio_led_platform_data gpio_led_info = {
-	.leds		= gpio_leds,
-	.num_leds	= ARRAY_SIZE(gpio_leds),
+	.access = 64,
+	.rd_cycle = 82,
+	.wr_cycle = 82,
+
+	.wr_access = 40,
+	.wr_data_mux_bus = 0,
 };
 
-static struct platform_device leds_gpio = {
-	.name	= "leds-gpio",
-	.id	= -1,
-	.dev	= {
-		.platform_data	= &gpio_led_info,
+static void evm_nand_init(void)
+{
+	struct omap_nand_platform_data *pdata;
+	struct gpmc_devices_info gpmc_device[2] = {
+		{ NULL, 0 },
+		{ NULL, 0 },
+	};
+
+	setup_pin_mux(nand_pin_mux);
+	pdata = omap_nand_init(am335x_nand_partitions,
+		ARRAY_SIZE(am335x_nand_partitions), 0, 0,
+		&am335x_nand_timings);
+	if (!pdata)
+		return;
+	pdata->ecc_opt = OMAP_ECC_BCH4_CODE_HW;
+	pdata->elm_used = true;
+	gpmc_device[0].pdata = pdata;
+	gpmc_device[0].flag = GPMC_DEVICE_NAND;
+
+	omap_init_gpmc(gpmc_device, sizeof(gpmc_device));
+	omap_init_elm();
+}
+
+static struct i2c_board_info __initdata am335x_i2c1_boardinfo[] = {
+#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+	{
+		I2C_BOARD_INFO("edt-ft5x06", 0x38),
+		.platform_data = &am335x_touchscreen_edt_data,
+		.irq = OMAP_GPIO_IRQ(FT5X06_IRQ),
 	},
+#endif
 };
 
-static void gpio_led_init(int evm_id, int profile)
+static void mmc0_init(void)
 {
-	int err;
+	setup_pin_mux(mmc0_common_pin_mux);
+	setup_pin_mux(mmc0_cd_only_pin_mux);
 
-	setup_pin_mux(gpio_led_mux);
-	err = platform_device_register(&leds_gpio);
-	if (err)
-		pr_err("failed to register gpio led device\n");
+	omap2_hsmmc_init(am335x_mmc);
+	return;
 }
 
 /* setup spi0 */
-static void spi0_init(int evm_id, int profile)
+static void spi0_init(void)
 {
 	setup_pin_mux(spi0_pin_mux);
 	spi_register_board_info(am335x_spi0_slave_info,
@@ -2002,36 +608,14 @@ static void spi0_init(int evm_id, int profile)
 	return;
 }
 
-/* setup spi1 */
-static void spi1_init(int evm_id, int profile)
-{
-	setup_pin_mux(spi1_pin_mux);
-	spi_register_board_info(am335x_spi1_slave_info,
-			ARRAY_SIZE(am335x_spi1_slave_info));
-	return;
-}
-
-
-static int beaglebone_phy_fixup(struct phy_device *phydev)
-{
-	phydev->supported &= ~(SUPPORTED_100baseT_Half |
-				SUPPORTED_100baseT_Full);
-
-	return 0;
-}
 
-static void profibus_init(int evm_id, int profile)
-{
-	setup_pin_mux(profibus_pin_mux);
-	return;
-}
 
 static struct omap_rtc_pdata am335x_rtc_info = {
 	.pm_off		= false,
 	.wakeup_capable	= 0,
 };
 
-static void am335x_rtc_init(int evm_id, int profile)
+static void am335x_rtc_init(void)
 {
 	void __iomem *base;
 	struct clk *clk;
@@ -2069,14 +653,7 @@ static void am335x_rtc_init(int evm_id, int profile)
 
 	iounmap(base);
 
-	switch (evm_id) {
-	case BEAGLE_BONE_A3:
-	case BEAGLE_BONE_OLD:
-		am335x_rtc_info.pm_off = true;
-		break;
-	default:
-		break;
-	}
+	am335x_rtc_info.pm_off = true;
 
 	clk_disable(clk);
 	clk_put(clk);
@@ -2102,7 +679,7 @@ static struct pinmux_config clkout2_pin_mux[] = {
 	{NULL, 0},
 };
 
-static void clkout2_enable(int evm_id, int profile)
+static void clkout2_enable(void)
 {
 	struct clk *ck_32;
 
@@ -2117,138 +694,7 @@ static void clkout2_enable(int evm_id, int profile)
 	setup_pin_mux(clkout2_pin_mux);
 }
 
-static void sgx_init(int evm_id, int profile)
-{
-	if (omap3_has_sgx()) {
-		am33xx_gpu_init();
-	}
-}
-/* General Purpose EVM */
-static struct evm_dev_cfg gen_purp_evm_dev_cfg[] = {
-	{am335x_rtc_init, DEV_ON_BASEBOARD, PROFILE_ALL},
-	{clkout2_enable, DEV_ON_BASEBOARD, PROFILE_ALL},
-	{enable_ecap0,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_1 |
-						PROFILE_2 | PROFILE_7) },
-	{lcdc_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_1 |
-						PROFILE_2 | PROFILE_7) },
-	{mfd_tscadc_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_1 |
-						PROFILE_2 | PROFILE_7) },
-	{rgmii1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{rgmii2_init,	DEV_ON_DGHTR_BRD, (PROFILE_1 | PROFILE_2 |
-						PROFILE_4 | PROFILE_6) },
-	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{evm_nand_init, DEV_ON_DGHTR_BRD,
-		(PROFILE_ALL & ~PROFILE_2 & ~PROFILE_3)},
-	{i2c1_init,     DEV_ON_DGHTR_BRD, (PROFILE_ALL & ~PROFILE_2)},
-	{lis331dlh_init, DEV_ON_DGHTR_BRD, (PROFILE_ALL & ~PROFILE_2)},
-	{mcasp1_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_3 | PROFILE_7)},
-	{mmc1_init,	DEV_ON_DGHTR_BRD, PROFILE_2},
-	{mmc2_wl12xx_init,	DEV_ON_BASEBOARD, (PROFILE_0 | PROFILE_3 |
-								PROFILE_5)},
-	{mmc0_init,	DEV_ON_BASEBOARD, (PROFILE_ALL & ~PROFILE_5)},
-	{mmc0_no_cd_init,	DEV_ON_BASEBOARD, PROFILE_5},
-	{spi0_init,	DEV_ON_DGHTR_BRD, PROFILE_2},
-	{uart1_wl12xx_init,	DEV_ON_BASEBOARD, (PROFILE_0 | PROFILE_3 |
-								PROFILE_5)},
-	{wl12xx_init,	DEV_ON_BASEBOARD, (PROFILE_0 | PROFILE_3 | PROFILE_5)},
-	{d_can_init,	DEV_ON_DGHTR_BRD, PROFILE_1},
-	{matrix_keypad_init, DEV_ON_DGHTR_BRD, PROFILE_0},
-	{volume_keys_init,  DEV_ON_DGHTR_BRD, PROFILE_0},
-	{uart2_init,	DEV_ON_DGHTR_BRD, PROFILE_3},
-	{haptics_init,	DEV_ON_DGHTR_BRD, (PROFILE_4)},
-	{sgx_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{NULL, 0, 0},
-};
-
-/* Industrial Auto Motor Control EVM */
-static struct evm_dev_cfg ind_auto_mtrl_evm_dev_cfg[] = {
-	{am335x_rtc_init, DEV_ON_BASEBOARD, PROFILE_ALL},
-	{clkout2_enable, DEV_ON_BASEBOARD, PROFILE_ALL},
-	{mii1_init,	DEV_ON_DGHTR_BRD, PROFILE_ALL},
-	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{profibus_init, DEV_ON_DGHTR_BRD, PROFILE_ALL},
-	{evm_nand_init, DEV_ON_DGHTR_BRD, PROFILE_ALL},
-	{spi1_init,	DEV_ON_DGHTR_BRD, PROFILE_ALL},
-	{uart3_init,	DEV_ON_DGHTR_BRD, PROFILE_ALL},
-	{i2c1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{mmc0_no_cd_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{NULL, 0, 0},
-};
-
-/* Beaglebone < Rev A3 */
-static struct evm_dev_cfg beaglebone_old_dev_cfg[] = {
-	{am335x_rtc_init, DEV_ON_BASEBOARD, PROFILE_NONE},
-	{clkout2_enable, DEV_ON_BASEBOARD, PROFILE_NONE},
-	{rmii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{sgx_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{NULL, 0, 0},
-};
-
-/* Beaglebone Rev A3 and after */
-static struct evm_dev_cfg beaglebone_dev_cfg[] = {
-	{am335x_rtc_init, DEV_ON_BASEBOARD, PROFILE_NONE},
-	{clkout2_enable, DEV_ON_BASEBOARD, PROFILE_NONE},
-	{tps65217_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{mii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{sgx_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{NULL, 0, 0},
-};
-
-/* EVM - Starter Kit */
-static struct evm_dev_cfg evm_sk_dev_cfg[] = {
-	{am335x_rtc_init, DEV_ON_BASEBOARD, PROFILE_ALL},
-	{mmc1_wl12xx_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{rgmii1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{rgmii2_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{lcdc_init,     DEV_ON_BASEBOARD, PROFILE_ALL},
-	{enable_ecap2,     DEV_ON_BASEBOARD, PROFILE_ALL},
-	{mfd_tscadc_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{gpio_keys_init,  DEV_ON_BASEBOARD, PROFILE_ALL},
-	{gpio_led_init,  DEV_ON_BASEBOARD, PROFILE_ALL},
-	{lis331dlh_init, DEV_ON_BASEBOARD, PROFILE_ALL},
-	{mcasp1_init,   DEV_ON_BASEBOARD, PROFILE_ALL},
-	{uart1_wl12xx_init, DEV_ON_BASEBOARD, PROFILE_ALL},
-	{wl12xx_init,       DEV_ON_BASEBOARD, PROFILE_ALL},
-	{gpio_ddr_vtt_enb_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
-	{sgx_init,       DEV_ON_BASEBOARD, PROFILE_ALL},
-	{NULL, 0, 0},
-};
-
-/* bytePANEL */
-static struct evm_dev_cfg bytepanel_dev_cfg[] = {
-	{am335x_rtc_init, DEV_ON_BASEBOARD, PROFILE_NONE},
-	{clkout2_enable, DEV_ON_BASEBOARD, PROFILE_ALL},
-	{mii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{lcdc_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{spi0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-        {evm_nand_init, DEV_ON_BASEBOARD, PROFILE_NONE},
-	{NULL, 0, 0},
-};
-
-static int am33xx_evm_tx_clk_dly_phy_fixup(struct phy_device *phydev)
-{
-	phy_write(phydev, AR8051_PHY_DEBUG_ADDR_REG,
-		  AR8051_DEBUG_RGMII_CLK_DLY_REG);
-	phy_write(phydev, AR8051_PHY_DEBUG_DATA_REG, AR8051_RGMII_TX_CLK_DLY);
-
-	return 0;
-}
-
-#define AM33XX_VDD_CORE_OPP50_UV		1100000
+#define AM33XX_VDD_CORE_OPP50_UV	1100000
 #define AM33XX_OPP120_FREQ		600000000
 #define AM33XX_OPPTURBO_FREQ		720000000
 
@@ -2344,95 +790,6 @@ static void am335x_opp_update(void)
 	}
 }
 
-static void setup_general_purpose_evm(void)
-{
-	u32 prof_sel = am335x_get_profile_selection();
-	u32 boardid = GEN_PURP_EVM;
-
-	if (!strncmp("1.5A", config.version, 4))
-		boardid = GEN_PURP_DDR3_EVM;
-
-	pr_info("The board is general purpose EVM %sin profile %d\n",
-			((boardid == GEN_PURP_DDR3_EVM) ? "with DDR3 " : ""),
-			prof_sel);
-
-	_configure_device(boardid, gen_purp_evm_dev_cfg, (1L << prof_sel));
-
-	am33xx_cpsw_init(AM33XX_CPSW_MODE_RGMII, NULL, NULL);
-	/* Atheros Tx Clk delay Phy fixup */
-	phy_register_fixup_for_uid(AM335X_EVM_PHY_ID, AM335X_EVM_PHY_MASK,
-				   am33xx_evm_tx_clk_dly_phy_fixup);
-}
-
-static void setup_ind_auto_motor_ctrl_evm(void)
-{
-	u32 prof_sel = am335x_get_profile_selection();
-
-	pr_info("The board is an industrial automation EVM in profile %d\n",
-		prof_sel);
-
-	/* Only Profile 0 is supported */
-	if ((1L << prof_sel) != PROFILE_0) {
-		pr_err("AM335X: Only Profile 0 is supported\n");
-		pr_err("Assuming profile 0 & continuing\n");
-		prof_sel = PROFILE_0;
-	}
-
-	_configure_device(IND_AUT_MTR_EVM, ind_auto_mtrl_evm_dev_cfg,
-		PROFILE_0);
-
-	am33xx_cpsw_init(AM33XX_CPSW_MODE_MII, "0:1e", "0:00");
-}
-
-/* BeagleBone < Rev A3 */
-static void setup_beaglebone_old(void)
-{
-	pr_info("The board is a AM335x Beaglebone < Rev A3.\n");
-
-	/* Beagle Bone has Micro-SD slot which doesn't have Write Protect pin */
-	am335x_mmc[0].gpio_wp = -EINVAL;
-
-	_configure_device(BEAGLE_BONE_OLD, beaglebone_old_dev_cfg,
-								PROFILE_NONE);
-
-	phy_register_fixup_for_uid(BBB_PHY_ID, BBB_PHY_MASK,
-					beaglebone_phy_fixup);
-
-	am33xx_cpsw_init(AM33XX_CPSW_MODE_RMII, NULL, NULL);
-}
-
-/* BeagleBone after Rev A3 */
-static void setup_beaglebone(void)
-{
-	pr_info("The board is a AM335x Beaglebone.\n");
-
-	/* Beagle Bone has Micro-SD slot which doesn't have Write Protect pin */
-	am335x_mmc[0].gpio_wp = -EINVAL;
-
-	_configure_device(BEAGLE_BONE_A3, beaglebone_dev_cfg, PROFILE_NONE);
-
-	/* TPS65217 regulator has full constraints */
-	regulator_has_full_constraints();
-
-	am33xx_cpsw_init(AM33XX_CPSW_MODE_MII, NULL, NULL);
-}
-
-/* EVM - Starter Kit */
-static void setup_starterkit(void)
-{
-	pr_info("The board is a AM335x Starter Kit.\n");
-
-	/* Starter Kit has Micro-SD slot which doesn't have Write Protect pin */
-	am335x_mmc[0].gpio_wp = -EINVAL;
-
-	_configure_device(EVM_SK, evm_sk_dev_cfg, PROFILE_NONE);
-
-	am33xx_cpsw_init(AM33XX_CPSW_MODE_RGMII, NULL, NULL);
-	/* Atheros Tx Clk delay Phy fixup */
-	phy_register_fixup_for_uid(AM335X_EVM_PHY_ID, AM335X_EVM_PHY_MASK,
-				   am33xx_evm_tx_clk_dly_phy_fixup);
-}
-
 /* bytepanel */
 static void setup_bytepanel(void)
 {
@@ -2441,10 +798,17 @@ static void setup_bytepanel(void)
 	/* bytePANEL has Micro-SD slot which doesn't have Write Protect pin */
 	am335x_mmc[0].gpio_wp = -EINVAL;
 
-        am335x_bytepanel_ads7846_init();
+	am335x_bytepanel_ads7846_init();
 
-
-	_configure_device(BEAGLE_BONE_OLD, bytepanel_dev_cfg, PROFILE_NONE);
+	am335x_rtc_init();
+	clkout2_enable();
+	mii1_init();
+	usb0_init();
+	usb1_init();
+	mmc0_init();
+	lcdc_init();
+	spi0_init();
+	evm_nand_init();
 
 	am33xx_cpsw_init(AM33XX_CPSW_MODE_MII, NULL, NULL);
 
@@ -2458,124 +822,6 @@ static void am335x_bytepanel_eeprom_setup(struct memory_accessor *mem_acc, void
 	am335x_opp_update();
 }
 
-static void am335x_setup_daughter_board(struct memory_accessor *m, void *c)
-{
-	int ret;
-
-	/*
-	 * Read from the EEPROM to see the presence of daughter board.
-	 * If present, print the cpld version.
-	 */
-
-	ret = m->read(m, (char *)&config1, 0, sizeof(config1));
-	if (ret == sizeof(config1)) {
-		pr_info("Detected a daughter card on AM335x EVM..");
-		daughter_brd_detected = true;
-	}
-	 else {
-		pr_info("No daughter card found\n");
-		daughter_brd_detected = false;
-		return;
-	}
-
-	if (!strncmp("CPLD", config1.cpld_ver, 4))
-		pr_info("CPLD version: %s\n", config1.cpld_ver);
-	else
-		pr_err("Unknown CPLD version found\n");
-}
-
-static void am335x_evm_setup(struct memory_accessor *mem_acc, void *context)
-{
-	int ret;
-	char tmp[10];
-
-	/* 1st get the MAC address from EEPROM */
-	ret = mem_acc->read(mem_acc, (char *)&am335x_mac_addr,
-		EEPROM_MAC_ADDRESS_OFFSET, sizeof(am335x_mac_addr));
-
-	if (ret != sizeof(am335x_mac_addr)) {
-		pr_warning("AM335X: EVM Config read fail: %d\n", ret);
-		return;
-	}
-
-	/* Fillup global mac id */
-	am33xx_cpsw_macidfillup(&am335x_mac_addr[0][0],
-				&am335x_mac_addr[1][0]);
-
-	/* get board specific data */
-	ret = mem_acc->read(mem_acc, (char *)&config, 0, sizeof(config));
-	if (ret != sizeof(config)) {
-		pr_err("AM335X EVM config read fail, read %d bytes\n", ret);
-		pr_err("This likely means that there either is no/or a failed EEPROM\n");
-		goto out;
-	}
-
-	if (config.header != AM335X_EEPROM_HEADER) {
-		pr_err("AM335X: wrong header 0x%x, expected 0x%x\n",
-			config.header, AM335X_EEPROM_HEADER);
-		goto out;
-	}
-
-	if (strncmp("A335", config.name, 4)) {
-		pr_err("Board %s\ndoesn't look like an AM335x board\n",
-			config.name);
-		goto out;
-	}
-
-	snprintf(tmp, sizeof(config.name) + 1, "%s", config.name);
-	pr_info("Board name: %s\n", tmp);
-	snprintf(tmp, sizeof(config.version) + 1, "%s", config.version);
-	pr_info("Board version: %s\n", tmp);
-
-	if (!strncmp("A335BONE", config.name, 8)) {
-		daughter_brd_detected = false;
-		if(!strncmp("00A1", config.version, 4) ||
-		   !strncmp("00A2", config.version, 4))
-			setup_beaglebone_old();
-		else
-			setup_beaglebone();
-	} else if (!strncmp("A335X_SK", config.name, 8)) {
-		daughter_brd_detected = false;
-		setup_starterkit();
-	} else {
-		/* only 6 characters of options string used for now */
-		snprintf(tmp, 7, "%s", config.opt);
-		pr_info("SKU: %s\n", tmp);
-
-		if (!strncmp("SKU#01", config.opt, 6))
-			setup_general_purpose_evm();
-		else if (!strncmp("SKU#02", config.opt, 6))
-			setup_ind_auto_motor_ctrl_evm();
-		else
-			goto out;
-	}
-
-	am335x_opp_update();
-
-	return;
-
-out:
-	/*
-	 * If the EEPROM hasn't been programed or an incorrect header
-	 * or board name are read then the hardware details are unknown.
-	 * Notify the user and call machine_halt to stop the boot process.
-	 */
-	pr_err("The error message above indicates that there is an issue with\n"
-		   "the EEPROM or the EEPROM contents.  After verifying the EEPROM\n"
-		   "contents, if any, refer to the %s function in the\n"
-		   "%s file to modify the board\n"
-		   "initialization code to match the hardware configuration\n",
-		   __func__ , __FILE__);
-	machine_halt();
-}
-
-static struct at24_platform_data am335x_daughter_board_eeprom_info = {
-	.byte_len       = (256*1024) / 8,
-	.page_size      = 64,
-	.flags          = AT24_FLAG_ADDR16,
-	.setup          = am335x_setup_daughter_board,
-	.context        = (void *)NULL,
-};
 
 static struct at24_platform_data am335x_bytepanel_eeprom_info = {
 	.byte_len       = (256*1024) / 8,
@@ -2647,14 +893,14 @@ static struct tps65910_board am335x_tps65910_info = {
 *	   eeprom probe is called last.
 */
 static struct i2c_board_info __initdata am335x_i2c0_boardinfo[] = {
-               {
-                I2C_BOARD_INFO("24c256", 0x50),
+	{
+		I2C_BOARD_INFO("24c256", 0x50),
 		.platform_data  = &am335x_bytepanel_eeprom_info,
-               },
-               {
+	},
+	{
 		I2C_BOARD_INFO("tps65910", TPS65910_I2C_ID1),
 		.platform_data  = &am335x_tps65910_info,
-               },
+	},
 };
 
 
@@ -2676,8 +922,8 @@ static void __init am335x_evm_i2c_init(void)
 	omap_register_i2c_bus(1, 100, am335x_i2c0_boardinfo,
 				ARRAY_SIZE(am335x_i2c0_boardinfo));
 	setup_pin_mux(i2c1_pin_mux);
-        omap_register_i2c_bus(2, 100, am335x_i2c1_boardinfo,
-                        ARRAY_SIZE(am335x_i2c1_boardinfo));
+	omap_register_i2c_bus(2, 100, am335x_i2c1_boardinfo,
+			ARRAY_SIZE(am335x_i2c1_boardinfo));
 
 }
 
@@ -2759,7 +1005,7 @@ static void __init am335x_evm_init(void)
 	/* Create an alias for gfx/sgx clock */
 	if (clk_add_alias("sgx_ck", NULL, "gfx_fclk", NULL))
 		pr_warn("failed to create an alias: gfx_fclk --> sgx_ck\n");
-        setup_bytepanel();
+	setup_bytepanel();
 }
 
 static void __init am335x_evm_map_io(void)
-- 
1.7.10.4

